<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/iconv-lite/encodings/utf7.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/iconv-lite/encodings/utf7.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">287</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">115.44</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.51</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = &#039;utf7&#039;; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9&#039;\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as &quot;+&lt;base64&gt;-&quot;; single &quot;+&quot; char is encoded as &quot;+-&quot;.
    return new Buffer(str.replace(nonDirectChars, function(chunk) {
        return &quot;+&quot; + (chunk === &#039;+&#039; ? &#039;&#039; : 
            this.iconv.encode(chunk, &#039;utf16-be&#039;).toString(&#039;base64&#039;).replace(/=+$/, &#039;&#039;)) 
            + &quot;-&quot;;
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = &#039;&#039;;
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i &lt; 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = &#039;+&#039;.charCodeAt(0), 
    minusChar = &#039;-&#039;.charCodeAt(0),
    andChar = &#039;&amp;&#039;.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = &quot;&quot;, lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i &lt; buf.length; i++) {
        if (!inBase64) { // We&#039;re in direct mode.
            // Write direct chars until &#039;+&#039;
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), &quot;ascii&quot;); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI &amp;&amp; buf[i] == minusChar) {// &quot;+-&quot; -&gt; &quot;+&quot;
                    res += &quot;+&quot;;
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(new Buffer(b64str, &#039;base64&#039;), &quot;utf16-be&quot;);
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = &#039;&#039;;
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), &quot;ascii&quot;); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -&gt; 2x3 bytes -&gt; 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(new Buffer(b64str, &#039;base64&#039;), &quot;utf16-be&quot;);
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = &quot;&quot;;
    if (this.inBase64 &amp;&amp; this.base64Accum.length &gt; 0)
        res = this.iconv.decode(new Buffer(this.base64Accum, &#039;base64&#039;), &quot;utf16-be&quot;);

    this.inBase64 = false;
    this.base64Accum = &#039;&#039;;
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by &quot;&amp;&quot; instead of &quot;+&quot;
//  * Direct characters are 0x20-0x7E, except &quot;&amp;&quot; (0x26)
//  * In Base64, &quot;,&quot; is used instead of &quot;/&quot;
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with &#039;-&#039;)
//  * String must end in non-shifted position.
//  * &quot;-&amp;&quot; while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = new Buffer(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = new Buffer(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i &lt; str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 &lt;= uChar &amp;&amp; uChar &lt;= 0x7E) { // Direct character or &#039;&amp;&#039;.
            if (inBase64) {
                if (base64AccumIdx &gt; 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString(&#039;base64&#039;).replace(/\//g, &#039;,&#039;).replace(/=+$/, &#039;&#039;), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write &#039;-&#039;, then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -&gt; &#039;&amp;-&#039;
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write &#039;&amp;&#039;, then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar &gt;&gt; 8;
                base64Accum[base64AccumIdx++] = uChar &amp; 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString(&#039;base64&#039;).replace(/\//g, &#039;,&#039;), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = new Buffer(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx &gt; 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString(&#039;base64&#039;).replace(/\//g, &#039;,&#039;).replace(/=+$/, &#039;&#039;), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write &#039;-&#039;, then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = &#039;&#039;;
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[&#039;,&#039;.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = &quot;&quot;, lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, &#039;-&#039; is optional at the end).

    for (var i = 0; i &lt; buf.length; i++) {
        if (!inBase64) { // We&#039;re in direct mode.
            // Write direct chars until &#039;&amp;&#039;
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), &quot;ascii&quot;); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI &amp;&amp; buf[i] == minusChar) { // &quot;&amp;-&quot; -&gt; &quot;&amp;&quot;
                    res += &quot;&amp;&quot;;
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, &#039;/&#039;);
                    res += this.iconv.decode(new Buffer(b64str, &#039;base64&#039;), &quot;utf16-be&quot;);
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = &#039;&#039;;
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), &quot;ascii&quot;); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, &#039;/&#039;);

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -&gt; 2x3 bytes -&gt; 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(new Buffer(b64str, &#039;base64&#039;), &quot;utf16-be&quot;);
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = &quot;&quot;;
    if (this.inBase64 &amp;&amp; this.base64Accum.length &gt; 0)
        res = this.iconv.decode(new Buffer(this.base64Accum, &#039;base64&#039;), &quot;utf16-be&quot;);

    this.inBase64 = false;
    this.base64Accum = &#039;&#039;;
    return res;
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
