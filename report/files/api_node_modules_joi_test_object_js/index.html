<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/joi/test/object.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/joi/test/object.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.79</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1309</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">14.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Lab = require(&#039;lab&#039;);
var Code = require(&#039;code&#039;);
var Joi = require(&#039;../lib&#039;);
var Helper = require(&#039;./helper&#039;);


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.describe;
var it = lab.it;
var expect = Code.expect;


describe(&#039;object&#039;, function () {

    it(&#039;converts a json string to an object&#039;, function (done) {

        Joi.object().validate(&#039;{&quot;hi&quot;:true}&#039;, function (err, value) {

            expect(err).to.not.exist();
            expect(value.hi).to.equal(true);
            done();
        });
    });

    it(&#039;errors on non-object string&#039;, function (done) {

        Joi.object().validate(&#039;a string&#039;, function (err, value) {

            expect(err).to.exist();
            expect(value).to.equal(&#039;a string&#039;);
            done();
        });
    });

    it(&#039;validates an object&#039;, function (done) {

        var schema = Joi.object().required();
        Helper.validate(schema, [
            [{}, true],
            [{ hi: true }, true],
            [&#039;&#039;, false]
        ], done);
    });

    it(&#039;return object reference when no rules specified&#039;, function (done) {

        var schema = Joi.object({
            a: Joi.object()
        });

        var item = { x: 5 };
        schema.validate({ a: item }, function (err, value) {

            expect(value.a).to.equal(item);
            done();
        });
    });

    it(&#039;retains ignored values&#039;, function (done) {

        var schema = Joi.object();
        schema.validate({ a: 5 }, function (err, value) {

            expect(value.a).to.equal(5);
            done();
        });
    });

    it(&#039;retains skipped values&#039;, function (done) {

        var schema = Joi.object({ b: 5 }).unknown(true);
        schema.validate({ b: &#039;5&#039;, a: 5 }, function (err, value) {

            expect(value.a).to.equal(5);
            expect(value.b).to.equal(5);
            done();
        });
    });

    it(&#039;allows any key when schema is undefined&#039;, function (done) {

        Joi.object().validate({ a: 4 }, function (err, value) {

            expect(err).to.not.exist();

            Joi.object(undefined).validate({ a: 4 }, function (err2, value2) {

                expect(err2).to.not.exist();
                done();
            });
        });
    });

    it(&#039;allows any key when schema is null&#039;, function (done) {

        Joi.object(null).validate({ a: 4 }, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;throws on invalid object schema&#039;, function (done) {

        expect(function () {

            Joi.object(4);
        }).to.throw(&#039;Object schema must be a valid object&#039;);
        done();
    });

    it(&#039;throws on joi object schema&#039;, function (done) {

        expect(function () {

            Joi.object(Joi.object());
        }).to.throw(&#039;Object schema cannot be a joi schema&#039;);
        done();
    });

    it(&#039;skips conversion when value is undefined&#039;, function (done) {

        Joi.object({ a: Joi.object() }).validate(undefined, function (err, value) {

            expect(err).to.not.exist();
            expect(value).to.not.exist();
            done();
        });
    });

    it(&#039;errors on array&#039;, function (done) {

        Joi.object().validate([1, 2, 3], function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;should prevent extra keys from existing by default&#039;, function (done) {

        var schema = Joi.object({ item: Joi.string().required() }).required();
        Helper.validate(schema, [
            [{ item: &#039;something&#039; }, true],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039; }, false],
            [&#039;&#039;, false]
        ], done);
    });

    it(&#039;should validate count when min is set&#039;, function (done) {

        var schema = Joi.object().min(3);
        Helper.validate(schema, [
            [{ item: &#039;something&#039; }, false],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039; }, false],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039;, item3: &#039;something something else&#039; }, true],
            [&#039;&#039;, false]
        ], done);
    });

    it(&#039;should validate count when max is set&#039;, function (done) {

        var schema = Joi.object().max(2);
        Helper.validate(schema, [
            [{ item: &#039;something&#039; }, true],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039; }, true],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039;, item3: &#039;something something else&#039; }, false],
            [&#039;&#039;, false]
        ], done);
    });

    it(&#039;should validate count when min and max is set&#039;, function (done) {

        var schema = Joi.object().max(3).min(2);
        Helper.validate(schema, [
            [{ item: &#039;something&#039; }, false],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039; }, true],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039;, item3: &#039;something something else&#039; }, true],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039;, item3: &#039;something something else&#039;, item4: &#039;item4&#039; }, false],
            [&#039;&#039;, false]
        ], done);
    });

    it(&#039;should validate count when length is set&#039;, function (done) {

        var schema = Joi.object().length(2);
        Helper.validate(schema, [
            [{ item: &#039;something&#039; }, false],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039; }, true],
            [{ item: &#039;something&#039;, item2: &#039;something else&#039;, item3: &#039;something something else&#039; }, false],
            [&#039;&#039;, false]
        ], done);
    });

    it(&#039;should validate constructor when type is set&#039;, function (done) {

        var schema = Joi.object().type(RegExp);
        Helper.validate(schema, [
            [{ item: &#039;something&#039; }, false],
            [&#039;&#039;, false],
            [new Date(), false],
            [/abcd/, true],
            [new RegExp(), true]
        ], done);
    });

    it(&#039;should traverse an object and validate all properties in the top level&#039;, function (done) {

        var schema = Joi.object({
            num: Joi.number()
        });

        Helper.validate(schema, [
            [{ num: 1 }, true],
            [{ num: [1, 2, 3] }, false]
        ], done);
    });

    it(&#039;should traverse an object and child objects and validate all properties&#039;, function (done) {

        var schema = Joi.object({
            num: Joi.number(),
            obj: Joi.object({
                item: Joi.string()
            })
        });

        Helper.validate(schema, [
            [{ num: 1 }, true],
            [{ num: [1, 2, 3] }, false],
            [{ num: 1, obj: { item: &#039;something&#039; } }, true],
            [{ num: 1, obj: { item: 123 } }, false]
        ], done);
    });

    it(&#039;should traverse an object several levels&#039;, function (done) {

        var schema = Joi.object({
            obj: Joi.object({
                obj: Joi.object({
                    obj: Joi.object({
                        item: Joi.boolean()
                    })
                })
            })
        });

        Helper.validate(schema, [
            [{ num: 1 }, false],
            [{ obj: {} }, true],
            [{ obj: { obj: {} } }, true],
            [{ obj: { obj: { obj: {} } } }, true],
            [{ obj: { obj: { obj: { item: true } } } }, true],
            [{ obj: { obj: { obj: { item: 10 } } } }, false]
        ], done);
    });

    it(&#039;should traverse an object several levels with required levels&#039;, function (done) {

        var schema = Joi.object({
            obj: Joi.object({
                obj: Joi.object({
                    obj: Joi.object({
                        item: Joi.boolean()
                    })
                }).required()
            })
        });

        Helper.validate(schema, [
            [null, false],
            [undefined, true],
            [{}, true],
            [{ obj: {} }, false],
            [{ obj: { obj: {} } }, true],
            [{ obj: { obj: { obj: {} } } }, true],
            [{ obj: { obj: { obj: { item: true } } } }, true],
            [{ obj: { obj: { obj: { item: 10 } } } }, false]
        ], done);
    });

    it(&#039;should traverse an object several levels with required levels (without Joi.obj())&#039;, function (done) {

        var schema = {
            obj: {
                obj: {
                    obj: {
                        item: Joi.boolean().required()
                    }
                }
            }
        };

        Helper.validate(schema, [
            [null, false],
            [undefined, true],
            [{}, true],
            [{ obj: {} }, true],
            [{ obj: { obj: {} } }, true],
            [{ obj: { obj: { obj: {} } } }, false],
            [{ obj: { obj: { obj: { item: true } } } }, true],
            [{ obj: { obj: { obj: { item: 10 } } } }, false]
        ], done);
    });

    it(&#039;errors on unknown keys when functions allows&#039;, function (done) {

        var schema = Joi.object({ a: Joi.number() }).options({ skipFunctions: true });
        var obj = { a: 5, b: &#039;value&#039; };
        schema.validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;validates both valid() and with()&#039;, function (done) {

        var schema = Joi.object({
            first: Joi.valid(&#039;value&#039;),
            second: Joi.any()
        }).with(&#039;first&#039;, &#039;second&#039;);

        Helper.validate(schema, [
            [{ first: &#039;value&#039; }, false]
        ], done);
    });

    it(&#039;validates referenced arrays in valid()&#039;, function (done) {

        var schema = Joi.object({
            foo: Joi.valid(Joi.ref(&#039;$x&#039;))
        });

        Helper.validate(schema, [
            [{ foo: &#039;bar&#039; }, true, { context: { x: &#039;bar&#039; } }],
            [{ foo: &#039;bar&#039; }, true, { context: { x: [&#039;baz&#039;, &#039;bar&#039;] } }],
            [{ foo: &#039;bar&#039; }, false, { context: { x: &#039;baz&#039; } }],
            [{ foo: &#039;bar&#039; }, false, { context: { x: [&#039;baz&#039;, &#039;qux&#039;] } }],
            [{ foo: &#039;bar&#039; }, false]
        ], done);
    });

    it(&#039;errors on unknown nested keys with the correct path&#039;, function (done) {

        var schema = Joi.object({ a: Joi.object().keys({}) });
        var obj = { a: { b: &#039;value&#039; } };
        schema.validate(obj, function (err, value) {

            expect(err).to.exist();
            expect(err.details[0].path).to.equal(&#039;a.b&#039;);
            done();
        });
    });

    it(&#039;errors on unknown nested keys with the correct path at the root level&#039;, function (done) {

        var schema = Joi.object({ a: Joi.object().keys({}) });
        var obj = { c: &#039;hello&#039; };
        schema.validate(obj, function (err, value) {

            expect(err).to.exist();
            expect(err.details[0].path).to.equal(&#039;c&#039;);
            done();
        });
    });

    it(&#039;should work on prototype-less objects&#039;, function (done) {

        var input = Object.create(null);
        var schema = Joi.object().keys({
            a: Joi.number()
        });

        input.a = 1337;

        Joi.validate(input, schema, function (err) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;should be able to use rename safely with a fake hasOwnProperty&#039;, function (done) {

        var input = { a: 1, hasOwnProperty: &#039;foo&#039; };
        var schema = Joi.object().rename(&#039;b&#039;, &#039;a&#039;);

        Joi.validate(input, schema, function (err) {

            expect(err.message).to.equal(&#039;&quot;value&quot; cannot rename child &quot;b&quot; because override is disabled and target &quot;a&quot; exists&#039;);
            done();
        });
    });

    it(&#039;should be able to use object.with() safely with a fake hasOwnProperty&#039;, function (done) {

        var input = { a: 1, hasOwnProperty: &#039;foo&#039; };
        var schema = Joi.object({ a: 1 }).with(&#039;a&#039;, &#039;b&#039;);

        Joi.validate(input, schema, function (err) {

            expect(err.message).to.equal(&#039;&quot;hasOwnProperty&quot; is not allowed. &quot;a&quot; missing required peer &quot;b&quot;&#039;);
            done();
        });
    });

    describe(&#039;#keys&#039;, function () {

        it(&#039;allows any key&#039;, function (done) {

            var a = Joi.object({ a: 4 });
            var b = a.keys();
            a.validate({ b: 3 }, function (err, value) {

                expect(err).to.exist();
                b.validate({ b: 3 }, function (err2, value2) {

                    expect(err2).to.not.exist();
                    done();
                });
            });
        });

        it(&#039;forbids all keys&#039;, function (done) {

            var a = Joi.object();
            var b = a.keys({});
            a.validate({ b: 3 }, function (err, value) {

                expect(err).to.not.exist();
                b.validate({ b: 3 }, function (err2, value2) {

                    expect(err2).to.exist();
                    done();
                });
            });
        });

        it(&#039;adds to existing keys&#039;, function (done) {

            var a = Joi.object({ a: 1 });
            var b = a.keys({ b: 2 });
            a.validate({ a: 1, b: 2 }, function (err, value) {

                expect(err).to.exist();
                b.validate({ a: 1, b: 2 }, function (err2, value2) {

                    expect(err2).to.not.exist();
                    done();
                });
            });
        });

        it(&#039;overrides existing keys&#039;, function (done) {

            var a = Joi.object({ a: 1 });
            var b = a.keys({ a: Joi.string() });

            Helper.validate(a, [
                [{ a: 1 }, true, null, { a: 1 }],
                [{ a: &#039;1&#039; }, true, null, { a: 1 }],
                [{ a: &#039;2&#039; }, false, null, &#039;child &quot;a&quot; fails because [&quot;a&quot; must be one of [1]]&#039;]
            ], function () {

                Helper.validate(b, [
                    [{ a: 1 }, false, null, &#039;child &quot;a&quot; fails because [&quot;a&quot; must be a string]&#039;],
                    [{ a: &#039;1&#039; }, true, null, { a: &#039;1&#039; }]
                ], done);
            });
        });

        it(&#039;strips keys flagged with strip&#039;, function (done) {

            var schema = Joi.object({
                a: Joi.string().strip(),
                b: Joi.string()
            });
            schema.validate({ a: &#039;test&#039;, b: &#039;test&#039; }, function (err, value) {

                expect(err).to.not.exist();
                expect(value.a).to.not.exist();
                expect(value.b).to.equal(&#039;test&#039;);
                done();
            });
        });

        it(&#039;does not alter the original object when stripping keys&#039;, function (done) {

            var schema = Joi.object({
                a: Joi.string().strip(),
                b: Joi.string()
            });

            var valid = {
                a: &#039;test&#039;,
                b: &#039;test&#039;
            };

            schema.validate(valid, function (err, value) {

                expect(err).to.not.exist();
                expect(value.a).to.not.exist();
                expect(valid.a).to.equal(&#039;test&#039;);
                expect(value.b).to.equal(&#039;test&#039;);
                expect(valid.b).to.equal(&#039;test&#039;);
                done();
            });
        });

        it(&#039;should strip from an alternative&#039;, function (done) {

            var schema = Joi.object({
                a: [Joi.boolean().strip()]
            });

            var valid = {
                a: true
            };

            schema.validate(valid, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal({});
                done();
            });
        });
    });

    describe(&#039;#unknown&#039;, function () {

        it(&#039;allows local unknown without applying to children&#039;, function (done) {

            var schema = Joi.object({
                a: {
                    b: Joi.number()
                }
            }).unknown();

            Helper.validate(schema, [
                [{ a: { b: 5 } }, true],
                [{ a: { b: &#039;x&#039; } }, false],
                [{ a: { b: 5 }, c: &#039;ignore&#039; }, true],
                [{ a: { b: 5, c: &#039;ignore&#039; } }, false]
            ], done);
        });

        it(&#039;forbids local unknown without applying to children&#039;, function (done) {

            var schema = Joi.object({
                a: Joi.object({
                    b: Joi.number()
                }).unknown()
            }).options({ allowUnknown: false });

            Helper.validate(schema, [
                [{ a: { b: 5 } }, true],
                [{ a: { b: &#039;x&#039; } }, false],
                [{ a: { b: 5 }, c: &#039;ignore&#039; }, false],
                [{ a: { b: 5, c: &#039;ignore&#039; } }, true]
            ], done);
        });
    });

    describe(&#039;#rename&#039;, function () {

        it(&#039;allows renaming multiple times with multiple enabled&#039;, function (done) {

            var schema = Joi.object({
                test: Joi.string()
            }).rename(&#039;test1&#039;, &#039;test&#039;).rename(&#039;test2&#039;, &#039;test&#039;, { multiple: true });

            Joi.compile(schema).validate({ test1: &#039;a&#039;, test2: &#039;b&#039; }, function (err, value) {

                expect(err).to.not.exist();
                done();
            });
        });

        it(&#039;errors renaming multiple times with multiple disabled&#039;, function (done) {

            var schema = Joi.object({
                test: Joi.string()
            }).rename(&#039;test1&#039;, &#039;test&#039;).rename(&#039;test2&#039;, &#039;test&#039;);

            Joi.compile(schema).validate({ test1: &#039;a&#039;, test2: &#039;b&#039; }, function (err, value) {

                expect(err.message).to.equal(&#039;&quot;value&quot; cannot rename child &quot;test2&quot; because multiple renames are disabled and another key was already renamed to &quot;test&quot;&#039;);
                done();
            });
        });

        it(&#039;errors multiple times when abortEarly is false&#039;, function (done) {

            Joi.object().rename(&#039;a&#039;, &#039;b&#039;).rename(&#039;c&#039;, &#039;b&#039;).rename(&#039;d&#039;, &#039;b&#039;).options({ abortEarly: false }).validate({ a: 1, c: 1, d: 1 }, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; cannot rename child &quot;c&quot; because multiple renames are disabled and another key was already renamed to &quot;b&quot;. &quot;value&quot; cannot rename child &quot;d&quot; because multiple renames are disabled and another key was already renamed to &quot;b&quot;&#039;);
                done();
            });
        });

        it(&#039;aliases a key&#039;, function (done) {

            var schema = Joi.object({
                a: Joi.number(),
                b: Joi.number()
            }).rename(&#039;a&#039;, &#039;b&#039;, { alias: true });

            var obj = { a: 10 };

            Joi.compile(schema).validate(obj, function (err, value) {

                expect(err).to.not.exist();
                expect(value.a).to.equal(10);
                expect(value.b).to.equal(10);
                done();
            });
        });

        it(&#039;with override disabled should not allow overwriting existing value&#039;, function (done) {

            var schema = Joi.object({
                test1: Joi.string()
            }).rename(&#039;test&#039;, &#039;test1&#039;);

            schema.validate({ test: &#039;b&#039;, test1: &#039;a&#039; }, function (err, value) {

                expect(err.message).to.equal(&#039;&quot;value&quot; cannot rename child &quot;test&quot; because override is disabled and target &quot;test1&quot; exists&#039;);
                done();
            });
        });

        it(&#039;with override enabled should allow overwriting existing value&#039;, function (done) {

            var schema = Joi.object({
                test1: Joi.string()
            }).rename(&#039;test&#039;, &#039;test1&#039;, { override: true });

            schema.validate({ test: &#039;b&#039;, test1: &#039;a&#039; }, function (err, value) {

                expect(err).to.not.exist();
                done();
            });
        });

        it(&#039;renames when data is nested in an array via items&#039;, function (done) {

            var schema = {
                arr: Joi.array().items(Joi.object({
                    one: Joi.string(),
                    two: Joi.string()
                }).rename(&#039;uno&#039;, &#039;one&#039;).rename(&#039;dos&#039;, &#039;two&#039;))
            };

            var data = { arr: [{ uno: &#039;1&#039;, dos: &#039;2&#039; }] };
            Joi.object(schema).validate(data, function (err, value) {

                expect(err).to.not.exist();
                expect(value.arr[0].one).to.equal(&#039;1&#039;);
                expect(value.arr[0].two).to.equal(&#039;2&#039;);
                done();
            });
        });

        it(&#039;applies rename and validation in the correct order regardless of key order&#039;, function (done) {

            var schema1 = Joi.object({
                a: Joi.number()
            }).rename(&#039;b&#039;, &#039;a&#039;);

            var input1 = { b: &#039;5&#039; };

            schema1.validate(input1, function (err1, value1) {

                expect(err1).to.not.exist();
                expect(value1.b).to.not.exist();
                expect(value1.a).to.equal(5);

                var schema2 = Joi.object({ a: Joi.number(), b: Joi.any() }).rename(&#039;b&#039;, &#039;a&#039;);
                var input2 = { b: &#039;5&#039; };

                schema2.validate(input2, function (err2, value2) {

                    expect(err2).to.not.exist();
                    expect(value2.b).to.not.exist();
                    expect(value2.a).to.equal(5);

                    done();
                });
            });
        });

        it(&#039;sets the default value after key is renamed&#039;, function (done) {

            var schema = Joi.object({
                foo2: Joi.string().default(&#039;test&#039;)
            }).rename(&#039;foo&#039;, &#039;foo2&#039;);

            var input = {};

            Joi.validate(input, schema, function (err, value) {

                expect(err).to.not.exist();
                expect(value.foo2).to.equal(&#039;test&#039;);

                done();
            });
        });

        it(&#039;should be able to rename keys that are empty strings&#039;, function (done) {

            var schema = Joi.object().rename(&#039;&#039;, &#039;notEmpty&#039;);
            var input = {
                &#039;&#039;: &#039;something&#039;
            };

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value[&#039;&#039;]).to.not.exist();
                expect(value.notEmpty).to.equal(&#039;something&#039;);
                done();
            });
        });

        it(&#039;should not create new keys when they key in question does not exist&#039;, function (done) {

            var schema = Joi.object().rename(&#039;b&#039;, &#039;_b&#039;);

            var input = {
                a: &#039;something&#039;
            };

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(Object.keys(value)).to.include(&#039;a&#039;);
                expect(value.a).to.equal(&#039;something&#039;);
                done();
            });
        });

        it(&#039;should remove a key with override if from does not exist&#039;, function (done) {

            var schema = Joi.object().rename(&#039;b&#039;, &#039;a&#039;, { override: true });

            var input = {
                a: &#039;something&#039;
            };

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal({});
                done();
            });
        });

        it(&#039;should ignore a key with ignoredUndefined if from does not exist&#039;, function (done){

            var schema = Joi.object().rename(&#039;b&#039;, &#039;a&#039;, { ignoreUndefined: true });

            var input = {
                a: &#039;something&#039;
            };

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal({ a: &#039;something&#039; });
                done();
            });
        });

        it(&#039;shouldn\&#039;t delete a key with override and ignoredUndefined if from does not exist&#039;, function (done){

            var schema = Joi.object().rename(&#039;b&#039;, &#039;a&#039;, { ignoreUndefined: true, override: true });

            var input = {
                a: &#039;something&#039;
            };

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal({ a: &#039;something&#039; });
                done();
            });
        });
    });

    describe(&#039;#describe&#039;, function () {

        it(&#039;return empty description when no schema defined&#039;, function (done) {

            var schema = Joi.object();
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;object&#039;
            });
            done();
        });

        it(&#039;respects the shallow parameter&#039;, function (done) {

            var schema = Joi.object({
                name: Joi.string(),
                child: Joi.object({
                    name: Joi.string()
                })
            });

            expect(Object.keys(schema.describe(true))).to.not.include(&#039;children&#039;);
            expect(Object.keys(schema.describe())).to.include(&#039;children&#039;);

            done();
        });

        it(&#039;describes patterns&#039;, function (done) {

            var schema = Joi.object({
                a: Joi.string()
            }).pattern(/\w\d/i, Joi.boolean());

            expect(schema.describe()).to.deep.equal({
                type: &#039;object&#039;,
                children: {
                    a: {
                        type: &#039;string&#039;,
                        invalids: [&#039;&#039;]
                    }
                },
                patterns: [
                    {
                        regex: &#039;/\\w\\d/i&#039;,
                        rule: {
                            type: &#039;boolean&#039;
                        }
                    }
                ]
            });

            done();
        });
    });

    describe(&#039;#length&#039;, function () {

        it(&#039;throws when length is not a number&#039;, function (done) {

            expect(function () {

                Joi.object().length(&#039;a&#039;);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });
    });

    describe(&#039;#min&#039;, function () {

        it(&#039;throws when limit is not a number&#039;, function (done) {

            expect(function () {

                Joi.object().min(&#039;a&#039;);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });
    });

    describe(&#039;#max&#039;, function () {

        it(&#039;throws when limit is not a number&#039;, function (done) {

            expect(function () {

                Joi.object().max(&#039;a&#039;);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });
    });

    describe(&#039;#pattern&#039;, function () {

        it(&#039;shows path to errors in schema&#039;, function (done) {

            expect(function () {

                Joi.object().pattern(/.*/, {
                    a: {
                        b: {
                            c: {
                                d: undefined
                            }
                        }
                    }
                });
            }).to.throw(Error, &#039;Invalid schema content: (a.b.c.d)&#039;);

            expect(function () {

                Joi.object().pattern(/.*/, function () {

                });
            }).to.throw(Error, &#039;Invalid schema content: &#039;);

            done();
        });

        it(&#039;validates unknown keys using a pattern&#039;, function (done) {

            var schema = Joi.object({
                a: Joi.number()
            }).pattern(/\d+/, Joi.boolean()).pattern(/\w\w+/, &#039;x&#039;);

            Joi.validate({ bb: &#039;y&#039;, 5: &#039;x&#039; }, schema, { abortEarly: false }, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;child &quot;5&quot; fails because [&quot;5&quot; must be a boolean]. child &quot;bb&quot; fails because [&quot;bb&quot; must be one of [x]]&#039;);

                Helper.validate(schema, [
                    [{ a: 5 }, true],
                    [{ a: &#039;x&#039; }, false],
                    [{ b: &#039;x&#039; }, false],
                    [{ bb: &#039;x&#039; }, true],
                    [{ 5: &#039;x&#039; }, false],
                    [{ 5: false }, true],
                    [{ 5: undefined }, true]
                ], done);
            });
        });

        it(&#039;validates unknown keys using a pattern (nested)&#039;, function (done) {

            var schema = {
                x: Joi.object({
                    a: Joi.number()
                }).pattern(/\d+/, Joi.boolean()).pattern(/\w\w+/, &#039;x&#039;)
            };

            Joi.validate({ x: { bb: &#039;y&#039;, 5: &#039;x&#039; } }, schema, { abortEarly: false }, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;child &quot;x&quot; fails because [child &quot;5&quot; fails because [&quot;5&quot; must be a boolean], child &quot;bb&quot; fails because [&quot;bb&quot; must be one of [x]]]&#039;);
                done();
            });
        });

        it(&#039;errors when using a pattern on empty schema with unknown(false) and pattern mismatch&#039;, function (done) {

            var schema = Joi.object().pattern(/\d/, Joi.number()).unknown(false);

            Joi.validate({ a: 5 }, schema, { abortEarly: false }, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;a&quot; is not allowed&#039;);
                done();
            });
        });

        it(&#039;removes global flag from patterns&#039;, function (done) {

            var schema = Joi.object().pattern(/a/g, Joi.number());

            Joi.validate({ a1: 5, a2: 6 }, schema, function (err, value) {

                expect(err).to.not.exist();
                done();
            });
        });
    });

    describe(&#039;#with&#039;, function () {

        it(&#039;should throw an error when a parameter is not a string&#039;, function (done) {

            try {
                Joi.object().with({});
                var error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);

            try {
                Joi.object().with(123);
                error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);
            done();
        });

        it(&#039;should validate correctly when key is an empty string&#039;, function (done) {

            var schema = Joi.object().with(&#039;&#039;, &#039;b&#039;);
            Helper.validate(schema, [
                [{ c: &#039;hi&#039;, d: &#039;there&#039; }, true]
            ]);
            done();
        });
    });

    describe(&#039;#without&#039;, function () {

        it(&#039;should throw an error when a parameter is not a string&#039;, function (done) {

            try {
                Joi.object().without({});
                var error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);

            try {
                Joi.object().without(123);
                error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);


            done();
        });

        it(&#039;should validate correctly when key is an empty string&#039;, function (done) {

            var schema = Joi.object().without(&#039;&#039;, &#039;b&#039;);
            Helper.validate(schema, [
                [{ a: &#039;hi&#039;, b: &#039;there&#039; }, true]
            ]);
            done();
        });
    });

    describe(&#039;#xor&#039;, function () {

        it(&#039;should throw an error when a parameter is not a string&#039;, function (done) {

            try {
                Joi.object().xor({});
                var error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);

            try {
                Joi.object().xor(123);
                error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);
            done();
        });
    });

    describe(&#039;#or&#039;, function () {

        it(&#039;should throw an error when a parameter is not a string&#039;, function (done) {

            try {
                Joi.object().or({});
                var error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);

            try {
                Joi.object().or(123);
                error = false;
            }
            catch (e) {
                error = true;
            }
            expect(error).to.equal(true);
            done();
        });

        it(&#039;errors multiple levels deep&#039;, function (done) {

            Joi.object({
                a: {
                    b: Joi.object().or(&#039;x&#039;, &#039;y&#039;)
                }
            }).validate({ a: { b: { c: 1 } } }, function (err, value) {

                expect(err).to.exist();
                expect(err.details[0].path).to.equal(&#039;a.b&#039;);
                expect(err.message).to.equal(&#039;child &quot;a&quot; fails because [child &quot;b&quot; fails because [&quot;value&quot; must contain at least one of [x, y]]]&#039;);
                done();
            });
        });
    });

    describe(&#039;#assert&#039;, function () {

        it(&#039;shows path to errors in schema&#039;, function (done) {

            expect(function () {

                Joi.object().assert(&#039;a.b&#039;, {
                    a: {
                        b: {
                            c: {
                                d: undefined
                            }
                        }
                    }
                });
            }).to.throw(Error, &#039;Invalid schema content: (a.b.c.d)&#039;);
            done();
        });

        it(&#039;shows errors in schema&#039;, function (done) {

            expect(function () {

                Joi.object().assert(&#039;a.b&#039;, undefined);
            }).to.throw(Error, &#039;Invalid schema content: &#039;);
            done();
        });

        it(&#039;validates upwards reference&#039;, function (done) {

            var schema = Joi.object({
                a: {
                    b: Joi.string(),
                    c: Joi.number()
                },
                d: {
                    e: Joi.any()
                }
            }).assert(Joi.ref(&#039;d/e&#039;, { separator: &#039;/&#039; }), Joi.ref(&#039;a.c&#039;), &#039;equal to a.c&#039;);

            schema.validate({ a: { b: &#039;x&#039;, c: 5 }, d: { e: 6 } }, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;d.e&quot; validation failed because &quot;d.e&quot; failed to equal to a.c&#039;);

                Helper.validate(schema, [
                    [{ a: { b: &#039;x&#039;, c: 5 }, d: { e: 5 } }, true]
                ], done);
            });
        });

        it(&#039;validates upwards reference with implicit context&#039;, function (done) {

            var schema = Joi.object({
                a: {
                    b: Joi.string(),
                    c: Joi.number()
                },
                d: {
                    e: Joi.any()
                }
            }).assert(&#039;d.e&#039;, Joi.ref(&#039;a.c&#039;), &#039;equal to a.c&#039;);

            schema.validate({ a: { b: &#039;x&#039;, c: 5 }, d: { e: 6 } }, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;d.e&quot; validation failed because &quot;d.e&quot; failed to equal to a.c&#039;);

                Helper.validate(schema, [
                    [{ a: { b: &#039;x&#039;, c: 5 }, d: { e: 5 } }, true]
                ], done);
            });
        });

        it(&#039;throws when context is at root level&#039;, function (done) {

            expect(function () {

                Joi.object({
                    a: {
                        b: Joi.string(),
                        c: Joi.number()
                    },
                    d: {
                        e: Joi.any()
                    }
                }).assert(&#039;a&#039;, Joi.ref(&#039;d.e&#039;), &#039;equal to d.e&#039;);
            }).to.throw(&#039;Cannot use assertions for root level references - use direct key rules instead&#039;);
            done();
        });

        it(&#039;allows root level context ref&#039;, function (done) {

            expect(function () {

                Joi.object({
                    a: {
                        b: Joi.string(),
                        c: Joi.number()
                    },
                    d: {
                        e: Joi.any()
                    }
                }).assert(&#039;$a&#039;, Joi.ref(&#039;d.e&#039;), &#039;equal to d.e&#039;);
            }).to.not.throw();
            done();
        });

        it(&#039;provides a default message for failed assertions&#039;, function (done) {

            var schema = Joi.object({
                a: {
                    b: Joi.string(),
                    c: Joi.number()
                },
                d: {
                    e: Joi.any()
                }
            }).assert(&#039;d.e&#039;, Joi.boolean());

            schema.validate({
                d: {
                    e: []
                }
            }, function (err) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;d.e&quot; validation failed because &quot;d.e&quot; failed to pass the assertion test&#039;);
                done();
            });
        });
    });

    describe(&#039;#type&#039;, function () {

        it(&#039;uses constructor name for default type name&#039;, function (done) {

            var Foo = function Foo () {};

            var schema = Joi.object().type(Foo);
            schema.validate({}, function (err) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; must be an instance of &quot;Foo&quot;&#039;);
                done();
            });
        });

        it(&#039;uses custom type name if supplied&#039;, function (done) {

            var Foo = function () {};

            var schema = Joi.object().type(Foo, &#039;Bar&#039;);
            schema.validate({}, function (err) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; must be an instance of &quot;Bar&quot;&#039;);
                done();
            });
        });

        it(&#039;overrides constructor name with custom name&#039;, function (done) {

            var Foo = function Foo () {};

            var schema = Joi.object().type(Foo, &#039;Bar&#039;);
            schema.validate({}, function (err) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; must be an instance of &quot;Bar&quot;&#039;);
                done();
            });
        });

        it(&#039;throws when constructor is not a function&#039;, function (done) {

            expect(function () {

                Joi.object().type(&#039;&#039;);
            }).to.throw(&#039;type must be a constructor function&#039;);
            done();
        });

        it(&#039;uses the constructor name in the schema description&#039;, function (done) {

            var description = Joi.object().type(RegExp).describe();

            expect(description.rules).to.deep.include({ name: &#039;type&#039;, arg: &#039;RegExp&#039; });
            done();
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
