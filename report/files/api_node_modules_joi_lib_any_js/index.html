<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/joi/lib/any.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/joi/lib/any.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">899</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">126.13</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Hoek = require(&#039;hoek&#039;);
var Ref = require(&#039;./ref&#039;);
var Errors = require(&#039;./errors&#039;);
var Alternatives = null;                // Delay-loaded to prevent circular dependencies
var Cast = null;


// Declare internals

var internals = {};


internals.defaults = {
    abortEarly: true,
    convert: true,
    allowUnknown: false,
    skipFunctions: false,
    stripUnknown: false,
    language: {},
    presence: &#039;optional&#039;,
    raw: false,
    strip: false,
    noDefaults: false

    // context: null
};


internals.checkOptions = function (options) {

    var optionType = {
        abortEarly: &#039;boolean&#039;,
        convert: &#039;boolean&#039;,
        allowUnknown: &#039;boolean&#039;,
        skipFunctions: &#039;boolean&#039;,
        stripUnknown: &#039;boolean&#039;,
        language: &#039;object&#039;,
        presence: [&#039;string&#039;, &#039;required&#039;, &#039;optional&#039;, &#039;forbidden&#039;, &#039;ignore&#039;],
        raw: &#039;boolean&#039;,
        context: &#039;object&#039;,
        strip: &#039;boolean&#039;,
        noDefaults: &#039;boolean&#039;
    };

    var keys = Object.keys(options);
    for (var k = 0, kl = keys.length; k &lt; kl; ++k) {
        var key = keys[k];
        var opt = optionType[key];
        var type = opt;
        var values = null;

        if (Array.isArray(opt)) {
            type = opt[0];
            values = opt.slice(1);
        }

        Hoek.assert(type, &#039;unknown key &#039; + key);
        Hoek.assert(typeof options[key] === type, key + &#039; should be of type &#039; + type);
        if (values) {
            Hoek.assert(values.indexOf(options[key]) &gt;= 0, key + &#039; should be one of &#039; + values.join(&#039;, &#039;));
        }
    }
};


module.exports = internals.Any = function () {

    Cast = Cast || require(&#039;./cast&#039;);

    this.isJoi = true;
    this._type = &#039;any&#039;;
    this._settings = null;
    this._valids = new internals.Set();
    this._invalids = new internals.Set();
    this._tests = [];
    this._refs = [];
    this._flags = { /*
        presence: &#039;optional&#039;,                   // optional, required, forbidden, ignore
        allowOnly: false,
        allowUnknown: undefined,
        default: undefined,
        forbidden: false,
        encoding: undefined,
        insensitive: false,
        trim: false,
        case: undefined,                        // upper, lower
        empty: undefined,
        func: false
    */ };

    this._description = null;
    this._unit = null;
    this._notes = [];
    this._tags = [];
    this._examples = [];
    this._meta = [];

    this._inner = {};                           // Hash of arrays of immutable objects
};


internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects


internals.Any.prototype.clone = function () {

    var obj = Object.create(Object.getPrototypeOf(this));

    obj.isJoi = true;
    obj._type = this._type;
    obj._settings = internals.concatSettings(this._settings);
    obj._valids = Hoek.clone(this._valids);
    obj._invalids = Hoek.clone(this._invalids);
    obj._tests = this._tests.slice();
    obj._refs = this._refs.slice();
    obj._flags = Hoek.clone(this._flags);

    obj._description = this._description;
    obj._unit = this._unit;
    obj._notes = this._notes.slice();
    obj._tags = this._tags.slice();
    obj._examples = this._examples.slice();
    obj._meta = this._meta.slice();

    obj._inner = {};
    var inners = Object.keys(this._inner);
    for (var i = 0, il = inners.length; i &lt; il; ++i) {
        var key = inners[i];
        obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
    }

    return obj;
};


internals.Any.prototype.concat = function (schema) {

    Hoek.assert(schema &amp;&amp; schema.isJoi, &#039;Invalid schema object&#039;);
    Hoek.assert(this._type === &#039;any&#039; || schema._type === &#039;any&#039; || schema._type === this._type, &#039;Cannot merge type&#039;, this._type, &#039;with another type:&#039;, schema._type);

    var obj = this.clone();

    if (this._type === &#039;any&#039; &amp;&amp; schema._type !== &#039;any&#039;) {

        // Reset values as if we were &quot;this&quot;
        var tmpObj = schema.clone();
        var keysToRestore = [&#039;_settings&#039;, &#039;_valids&#039;, &#039;_invalids&#039;, &#039;_tests&#039;, &#039;_refs&#039;, &#039;_flags&#039;, &#039;_description&#039;, &#039;_unit&#039;,
            &#039;_notes&#039;, &#039;_tags&#039;, &#039;_examples&#039;, &#039;_meta&#039;, &#039;_inner&#039;];

        for (var j = 0, jl = keysToRestore.length; j &lt; jl; ++j) {
            tmpObj[keysToRestore[j]] = obj[keysToRestore[j]];
        }

        obj = tmpObj;
    }

    obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;
    obj._valids.merge(schema._valids, schema._invalids);
    obj._invalids.merge(schema._invalids, schema._valids);
    obj._tests = obj._tests.concat(schema._tests);
    obj._refs = obj._refs.concat(schema._refs);
    Hoek.merge(obj._flags, schema._flags);

    obj._description = schema._description || obj._description;
    obj._unit = schema._unit || obj._unit;
    obj._notes = obj._notes.concat(schema._notes);
    obj._tags = obj._tags.concat(schema._tags);
    obj._examples = obj._examples.concat(schema._examples);
    obj._meta = obj._meta.concat(schema._meta);

    var inners = Object.keys(schema._inner);
    var isObject = obj._type === &#039;object&#039;;
    for (var i = 0, il = inners.length; i &lt; il; ++i) {
        var key = inners[i];
        var source = schema._inner[key];
        if (source) {
            var target = obj._inner[key];
            if (target) {
                if (isObject &amp;&amp; key === &#039;children&#039;) {
                    var keys = {};

                    for (var k = 0, kl = target.length; k &lt; kl; ++k) {
                        keys[target[k].key] = k;
                    }

                    for (k = 0, kl = source.length; k &lt; kl; ++k) {
                        var sourceKey = source[k].key;
                        if (keys[sourceKey] &gt;= 0) {
                            target[keys[sourceKey]] = {
                                key: sourceKey,
                                schema: target[keys[sourceKey]].schema.concat(source[k].schema)
                            };
                        }
                        else {
                            target.push(source[k]);
                        }
                    }
                }
                else {
                    obj._inner[key] = obj._inner[key].concat(source);
                }
            }
            else {
                obj._inner[key] = source.slice();
            }
        }
    }

    return obj;
};


internals.Any.prototype._test = function (name, arg, func) {

    Hoek.assert(!this._flags.allowOnly, &#039;Cannot define rules when valid values specified&#039;);

    var obj = this.clone();
    obj._tests.push({ func: func, name: name, arg: arg });
    return obj;
};


internals.Any.prototype.options = function (options) {

    Hoek.assert(!options.context, &#039;Cannot override context&#039;);
    internals.checkOptions(options);

    var obj = this.clone();
    obj._settings = internals.concatSettings(obj._settings, options);
    return obj;
};


internals.Any.prototype.strict = function (isStrict) {

    var obj = this.clone();
    obj._settings = obj._settings || {};
    obj._settings.convert = isStrict === undefined ? false : !isStrict;
    return obj;
};


internals.Any.prototype.raw = function (isRaw) {

    var obj = this.clone();
    obj._settings = obj._settings || {};
    obj._settings.raw = isRaw === undefined ? true : isRaw;
    return obj;
};


internals.Any.prototype._allow = function () {

    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
    for (var i = 0, il = values.length; i &lt; il; ++i) {
        var value = values[i];

        Hoek.assert(value !== undefined, &#039;Cannot call allow/valid/invalid with undefined&#039;);
        this._invalids.remove(value);
        this._valids.add(value, this._refs);
    }
};


internals.Any.prototype.allow = function () {

    var obj = this.clone();
    obj._allow.apply(obj, arguments);
    return obj;
};


internals.Any.prototype.valid = internals.Any.prototype.only = internals.Any.prototype.equal = function () {

    Hoek.assert(!this._tests.length, &#039;Cannot set valid values when rules specified&#039;);

    var obj = this.allow.apply(this, arguments);
    obj._flags.allowOnly = true;
    return obj;
};


internals.Any.prototype.invalid = internals.Any.prototype.disallow = internals.Any.prototype.not = function (value) {

    var obj = this.clone();
    var values = Hoek.flatten(Array.prototype.slice.call(arguments));
    for (var i = 0, il = values.length; i &lt; il; ++i) {
        value = values[i];

        Hoek.assert(value !== undefined, &#039;Cannot call allow/valid/invalid with undefined&#039;);
        obj._valids.remove(value);
        obj._invalids.add(value, this._refs);
    }

    return obj;
};


internals.Any.prototype.required = internals.Any.prototype.exist = function () {

    var obj = this.clone();
    obj._flags.presence = &#039;required&#039;;
    return obj;
};


internals.Any.prototype.optional = function () {

    var obj = this.clone();
    obj._flags.presence = &#039;optional&#039;;
    return obj;
};


internals.Any.prototype.forbidden = function () {

    var obj = this.clone();
    obj._flags.presence = &#039;forbidden&#039;;
    return obj;
};


internals.Any.prototype.strip = function () {

    var obj = this.clone();
    obj._flags.strip = true;
    return obj;
};


internals.Any.prototype.applyFunctionToChildren = function (children, fn, args, root) {

    children = [].concat(children);

    if (children.length !== 1 || children[0] !== &#039;&#039;) {
        root = root ? (root + &#039;.&#039;) : &#039;&#039;;

        var extraChildren = (children[0] === &#039;&#039; ? children.slice(1) : children).map(function (child) {

            return root + child;
        });

        throw new Error(&#039;unknown key(s) &#039; + extraChildren.join(&#039;, &#039;));
    }

    return this[fn].apply(this, args);
};


internals.Any.prototype.default = function (value, description) {

    if (typeof value === &#039;function&#039; &amp;&amp;
        !Ref.isRef(value)) {

        if (!value.description &amp;&amp;
            description) {

            value.description = description;
        }

        if (!this._flags.func) {
            Hoek.assert(typeof value.description === &#039;string&#039; &amp;&amp; value.description.length &gt; 0, &#039;description must be provided when default value is a function&#039;);
        }
    }

    var obj = this.clone();
    obj._flags.default = value;
    Ref.push(obj._refs, value);
    return obj;
};


internals.Any.prototype.empty = function (schema) {

    var obj;
    if (schema === undefined) {
        obj = this.clone();
        obj._flags.empty = undefined;
    }
    else {
        schema = Cast.schema(schema);

        obj = this.clone();
        obj._flags.empty = schema;
    }

    return obj;
};


internals.Any.prototype.when = function (ref, options) {

    Hoek.assert(options &amp;&amp; typeof options === &#039;object&#039;, &#039;Invalid options&#039;);
    Hoek.assert(options.then !== undefined || options.otherwise !== undefined, &#039;options must have at least one of &quot;then&quot; or &quot;otherwise&quot;&#039;);

    var then = options.then ? this.concat(Cast.schema(options.then)) : this;
    var otherwise = options.otherwise ? this.concat(Cast.schema(options.otherwise)) : this;

    Alternatives = Alternatives || require(&#039;./alternatives&#039;);
    var obj = Alternatives.when(ref, { is: options.is, then: then, otherwise: otherwise });
    obj._flags.presence = &#039;ignore&#039;;
    return obj;
};


internals.Any.prototype.description = function (desc) {

    Hoek.assert(desc &amp;&amp; typeof desc === &#039;string&#039;, &#039;Description must be a non-empty string&#039;);

    var obj = this.clone();
    obj._description = desc;
    return obj;
};


internals.Any.prototype.notes = function (notes) {

    Hoek.assert(notes &amp;&amp; (typeof notes === &#039;string&#039; || Array.isArray(notes)), &#039;Notes must be a non-empty string or array&#039;);

    var obj = this.clone();
    obj._notes = obj._notes.concat(notes);
    return obj;
};


internals.Any.prototype.tags = function (tags) {

    Hoek.assert(tags &amp;&amp; (typeof tags === &#039;string&#039; || Array.isArray(tags)), &#039;Tags must be a non-empty string or array&#039;);

    var obj = this.clone();
    obj._tags = obj._tags.concat(tags);
    return obj;
};

internals.Any.prototype.meta = function (meta) {

    Hoek.assert(meta !== undefined, &#039;Meta cannot be undefined&#039;);

    var obj = this.clone();
    obj._meta = obj._meta.concat(meta);
    return obj;
};


internals.Any.prototype.example = function (value) {

    Hoek.assert(arguments.length, &#039;Missing example&#039;);
    var result = this._validate(value, null, internals.defaults);
    Hoek.assert(!result.errors, &#039;Bad example:&#039;, result.errors &amp;&amp; Errors.process(result.errors, value));

    var obj = this.clone();
    obj._examples = obj._examples.concat(value);
    return obj;
};


internals.Any.prototype.unit = function (name) {

    Hoek.assert(name &amp;&amp; typeof name === &#039;string&#039;, &#039;Unit name must be a non-empty string&#039;);

    var obj = this.clone();
    obj._unit = name;
    return obj;
};


internals._try = function (fn, arg) {

    var err;
    var result;

    try {
        result = fn.call(null, arg);
    } catch (e) {
        err = e;
    }

    return {
        value: result,
        error: err
    };
};


internals.Any.prototype._validate = function (value, state, options, reference) {

    var self = this;
    var originalValue = value;

    // Setup state and settings

    state = state || { key: &#039;&#039;, path: &#039;&#039;, parent: null, reference: reference };

    if (this._settings) {
        options = internals.concatSettings(options, this._settings);
    }

    var errors = [];
    var finish = function () {

        var finalValue;

        if (!self._flags.strip) {
            if (value !== undefined) {
                finalValue = options.raw ? originalValue : value;
            }
            else if (options.noDefaults) {
                finalValue = originalValue;
            }
            else if (Ref.isRef(self._flags.default)) {
                finalValue = self._flags.default(state.parent, options);
            }
            else if (typeof self._flags.default === &#039;function&#039; &amp;&amp;
                    !(self._flags.func &amp;&amp; !self._flags.default.description)) {

                var arg;

                if (state.parent !== null &amp;&amp;
                    self._flags.default.length &gt; 0) {

                    arg = Hoek.clone(state.parent);
                }

                var defaultValue = internals._try(self._flags.default, arg);
                finalValue = defaultValue.value;
                if (defaultValue.error) {
                    errors.push(Errors.create(&#039;any.default&#039;, defaultValue.error, state, options));
                }
            }
            else {
                finalValue = Hoek.clone(self._flags.default);
            }
        }

        return {
            value: finalValue,
            errors: errors.length ? errors : null
        };
    };

    // Check presence requirements

    var presence = this._flags.presence || options.presence;
    if (presence === &#039;optional&#039;) {
        if (value === undefined) {
            var isDeepDefault = this._flags.hasOwnProperty(&#039;default&#039;) &amp;&amp; this._flags.default === undefined;
            if (isDeepDefault &amp;&amp; this._type === &#039;object&#039;) {
                value = {};
            }
            else {
                return finish();
            }
        }
    }
    else if (presence === &#039;required&#039; &amp;&amp;
            value === undefined) {

        errors.push(Errors.create(&#039;any.required&#039;, null, state, options));
        return finish();
    }
    else if (presence === &#039;forbidden&#039;) {
        if (value === undefined) {
            return finish();
        }

        errors.push(Errors.create(&#039;any.unknown&#039;, null, state, options));
        return finish();
    }

    if (this._flags.empty &amp;&amp; !this._flags.empty._validate(value, null, internals.defaults).errors) {
        value = undefined;
        return finish();
    }

    // Check allowed and denied values using the original value

    if (this._valids.has(value, state, options, this._flags.insensitive)) {
        return finish();
    }

    if (this._invalids.has(value, state, options, this._flags.insensitive)) {
        errors.push(Errors.create(value === &#039;&#039; ? &#039;any.empty&#039; : &#039;any.invalid&#039;, null, state, options));
        if (options.abortEarly ||
            value === undefined) {          // No reason to keep validating missing value

            return finish();
        }
    }

    // Convert value and validate type

    if (this._base) {
        var base = this._base.call(this, value, state, options);
        if (base.errors) {
            value = base.value;
            errors = errors.concat(base.errors);
            return finish();                            // Base error always aborts early
        }

        if (base.value !== value) {
            value = base.value;

            // Check allowed and denied values using the converted value

            if (this._valids.has(value, state, options, this._flags.insensitive)) {
                return finish();
            }

            if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                errors.push(Errors.create(&#039;any.invalid&#039;, null, state, options));
                if (options.abortEarly) {
                    return finish();
                }
            }
        }
    }

    // Required values did not match

    if (this._flags.allowOnly) {
        errors.push(Errors.create(&#039;any.allowOnly&#039;, { valids: this._valids.values({ stripUndefined: true }) }, state, options));
        if (options.abortEarly) {
            return finish();
        }
    }

    // Helper.validate tests

    for (var i = 0, il = this._tests.length; i &lt; il; ++i) {
        var test = this._tests[i];
        var err = test.func.call(this, value, state, options);
        if (err) {
            errors.push(err);
            if (options.abortEarly) {
                return finish();
            }
        }
    }

    return finish();
};


internals.Any.prototype._validateWithOptions = function (value, options, callback) {

    if (options) {
        internals.checkOptions(options);
    }

    var settings = internals.concatSettings(internals.defaults, options);
    var result = this._validate(value, null, settings);
    var errors = Errors.process(result.errors, value);

    if (callback) {
        return callback(errors, result.value);
    }

    return { error: errors, value: result.value };
};


internals.Any.prototype.validate = function (value, callback) {

    var result = this._validate(value, null, internals.defaults);
    var errors = Errors.process(result.errors, value);

    if (callback) {
        return callback(errors, result.value);
    }

    return { error: errors, value: result.value };
};


internals.Any.prototype.describe = function () {

    var description = {
        type: this._type
    };

    var flags = Object.keys(this._flags);
    if (flags.length) {
        if (this._flags.empty) {
            description.flags = {};
            for (var f = 0, fl = flags.length; f &lt; fl; ++f) {
                var flag = flags[f];
                description.flags[flag] = flag === &#039;empty&#039; ? this._flags[flag].describe() : this._flags[flag];
            }
        }
        else {
            description.flags = this._flags;
        }
    }

    if (this._description) {
        description.description = this._description;
    }

    if (this._notes.length) {
        description.notes = this._notes;
    }

    if (this._tags.length) {
        description.tags = this._tags;
    }

    if (this._meta.length) {
        description.meta = this._meta;
    }

    if (this._examples.length) {
        description.examples = this._examples;
    }

    if (this._unit) {
        description.unit = this._unit;
    }

    var valids = this._valids.values();
    if (valids.length) {
        description.valids = valids;
    }

    var invalids = this._invalids.values();
    if (invalids.length) {
        description.invalids = invalids;
    }

    description.rules = [];

    for (var i = 0, il = this._tests.length; i &lt; il; ++i) {
        var validator = this._tests[i];
        var item = { name: validator.name };
        if (validator.arg !== void 0) {
            item.arg = validator.arg;
        }
        description.rules.push(item);
    }

    if (!description.rules.length) {
        delete description.rules;
    }

    var label = Hoek.reach(this._settings, &#039;language.label&#039;);
    if (label) {
        description.label = label;
    }

    return description;
};

internals.Any.prototype.label = function (name) {

    Hoek.assert(name &amp;&amp; typeof name === &#039;string&#039;, &#039;Label name must be a non-empty string&#039;);

    var obj = this.clone();
    var options = { language: { label: name } };

    // If language.label is set, it should override this label
    obj._settings = internals.concatSettings(options, obj._settings);
    return obj;
};


// Set

internals.Set = function () {

    this._set = [];
};


internals.Set.prototype.add = function (value, refs) {

    Hoek.assert(value === null || value === undefined || value instanceof Date || Buffer.isBuffer(value) || Ref.isRef(value) || (typeof value !== &#039;function&#039; &amp;&amp; typeof value !== &#039;object&#039;), &#039;Value cannot be an object or function&#039;);

    if (typeof value !== &#039;function&#039; &amp;&amp;
        this.has(value, null, null, false)) {

        return;
    }

    Ref.push(refs, value);
    this._set.push(value);
};


internals.Set.prototype.merge = function (add, remove) {

    for (var i = 0, il = add._set.length; i &lt; il; ++i) {
        this.add(add._set[i]);
    }

    for (i = 0, il = remove._set.length; i &lt; il; ++i) {
        this.remove(remove._set[i]);
    }
};


internals.Set.prototype.remove = function (value) {

    this._set = this._set.filter(function (item) {

        return value !== item;
    });
};


internals.Set.prototype.has = function (value, state, options, insensitive) {

    for (var i = 0, il = this._set.length; i &lt; il; ++i) {
        var items = this._set[i];

        if (Ref.isRef(items)) {
            items = items(state.reference || state.parent, options);
        }

        if (!Array.isArray(items)) {
            items = [items];
        }

        for (var j = 0, jl = items.length; j &lt; jl; ++j) {
            var item = items[j];
            if (typeof value !== typeof item) {
                continue;
            }

            if (value === item ||
                (value instanceof Date &amp;&amp; item instanceof Date &amp;&amp; value.getTime() === item.getTime()) ||
                (insensitive &amp;&amp; typeof value === &#039;string&#039; &amp;&amp; value.toLowerCase() === item.toLowerCase()) ||
                (Buffer.isBuffer(value) &amp;&amp; Buffer.isBuffer(item) &amp;&amp; value.length === item.length &amp;&amp; value.toString(&#039;binary&#039;) === item.toString(&#039;binary&#039;))) {

                return true;
            }
        }
    }

    return false;
};


internals.Set.prototype.values = function (options) {

    if (options &amp;&amp; options.stripUndefined) {
        var values = [];

        for (var i = 0, il = this._set.length; i &lt; il; ++i) {
            var item = this._set[i];
            if (item !== undefined) {
                values.push(item);
            }
        }

        return values;
    }

    return this._set.slice();
};


internals.concatSettings = function (target, source) {

    // Used to avoid cloning context

    if (!target &amp;&amp;
        !source) {

        return null;
    }

    var key, obj = {};

    if (target) {
        var tKeys = Object.keys(target);
        for (var i = 0, il = tKeys.length; i &lt; il; ++i) {
            key = tKeys[i];
            obj[key] = target[key];
        }
    }

    if (source) {
        var sKeys = Object.keys(source);
        for (var j = 0, jl = sKeys.length; j &lt; jl; ++j) {
            key = sKeys[j];
            if (key !== &#039;language&#039; ||
                !obj.hasOwnProperty(key)) {

                obj[key] = source[key];
            }
            else {
                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
            }
        }
    }

    return obj;
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
