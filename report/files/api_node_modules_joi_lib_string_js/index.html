<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/joi/lib/string.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/joi/lib/string.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.20</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">468</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">91.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.97</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Net = require(&#039;net&#039;);
var Hoek = require(&#039;hoek&#039;);
var Isemail = require(&#039;isemail&#039;);
var Any = require(&#039;./any&#039;);
var Ref = require(&#039;./ref&#039;);
var JoiDate = require(&#039;./date&#039;);
var Errors = require(&#039;./errors&#039;);
var Uri = require(&#039;./string/uri&#039;);
var Ip = require(&#039;./string/ip&#039;);

// Declare internals

var internals = {
    uriRegex: Uri.createUriRegex(),
    ipRegex: Ip.createIpRegex([&#039;ipv4&#039;, &#039;ipv6&#039;, &#039;ipvfuture&#039;], &#039;optional&#039;)
};

internals.String = function () {

    Any.call(this);
    this._type = &#039;string&#039;;
    this._invalids.add(&#039;&#039;);
};

Hoek.inherits(internals.String, Any);

internals.compare = function (type, compare) {

    return function (limit, encoding) {

        var isRef = Ref.isRef(limit);

        Hoek.assert((Hoek.isInteger(limit) &amp;&amp; limit &gt;= 0) || isRef, &#039;limit must be a positive integer or reference&#039;);
        Hoek.assert(!encoding || Buffer.isEncoding(encoding), &#039;Invalid encoding:&#039;, encoding);

        return this._test(type, limit, function (value, state, options) {

            var compareTo;
            if (isRef) {
                compareTo = limit(state.parent, options);

                if (!Hoek.isInteger(compareTo)) {
                    return Errors.create(&#039;string.ref&#039;, { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo, encoding)) {
                return null;
            }

            return Errors.create(&#039;string.&#039; + type, { limit: compareTo, value: value, encoding: encoding }, state, options);
        });
    };
};

internals.String.prototype._base = function (value, state, options) {

    if (typeof value === &#039;string&#039; &amp;&amp;
        options.convert) {

        if (this._flags.case) {
            value = (this._flags.case === &#039;upper&#039; ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
        }

        if (this._flags.trim) {
            value = value.trim();
        }

        if (this._inner.replacements) {

            for (var r = 0, rl = this._inner.replacements.length; r &lt; rl; ++r) {
                var replacement = this._inner.replacements[r];
                value = value.replace(replacement.pattern, replacement.replacement);
            }
        }
    }

    return {
        value: value,
        errors: (typeof value === &#039;string&#039;) ? null : Errors.create(&#039;string.base&#039;, { value: value }, state, options)
    };
};


internals.String.prototype.insensitive = function () {

    var obj = this.clone();
    obj._flags.insensitive = true;
    return obj;
};


internals.String.prototype.min = internals.compare(&#039;min&#039;, function (value, limit, encoding) {

    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length &gt;= limit;
});


internals.String.prototype.max = internals.compare(&#039;max&#039;, function (value, limit, encoding) {

    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length &lt;= limit;
});


internals.String.prototype.creditCard = function () {

    return this._test(&#039;creditCard&#039;, undefined, function (value, state, options) {

        var i = value.length;
        var sum = 0;
        var mul = 1;
        var char;

        while (i--) {
            char = value.charAt(i) * mul;
            sum += char - (char &gt; 9) * 9;
            mul ^= 3;
        }

        var check = (sum % 10 === 0) &amp;&amp; (sum &gt; 0);
        return check ? null : Errors.create(&#039;string.creditCard&#039;, { value: value }, state, options);
    });
};

internals.String.prototype.length = internals.compare(&#039;length&#039;, function (value, limit, encoding) {

    var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length === limit;
});


internals.String.prototype.regex = function (pattern, name) {

    Hoek.assert(pattern instanceof RegExp, &#039;pattern must be a RegExp&#039;);

    pattern = new RegExp(pattern.source, pattern.ignoreCase ? &#039;i&#039; : undefined);         // Future version should break this and forbid unsupported regex flags

    return this._test(&#039;regex&#039;, pattern, function (value, state, options) {

        if (pattern.test(value)) {
            return null;
        }

        return Errors.create((name ? &#039;string.regex.name&#039; : &#039;string.regex.base&#039;), { name: name, pattern: pattern, value: value }, state, options);
    });
};


internals.String.prototype.alphanum = function () {

    return this._test(&#039;alphanum&#039;, undefined, function (value, state, options) {

        if (/^[a-zA-Z0-9]+$/.test(value)) {
            return null;
        }

        return Errors.create(&#039;string.alphanum&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.token = function () {

    return this._test(&#039;token&#039;, undefined, function (value, state, options) {

        if (/^\w+$/.test(value)) {
            return null;
        }

        return Errors.create(&#039;string.token&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.email = function (isEmailOptions) {

    if (isEmailOptions) {
        Hoek.assert(typeof isEmailOptions === &#039;object&#039;, &#039;email options must be an object&#039;);
        Hoek.assert(typeof isEmailOptions.checkDNS === &#039;undefined&#039;, &#039;checkDNS option is not supported&#039;);
        Hoek.assert(typeof isEmailOptions.tldWhitelist === &#039;undefined&#039; ||
            typeof isEmailOptions.tldWhitelist === &#039;object&#039;, &#039;tldWhitelist must be an array or object&#039;);
        Hoek.assert(typeof isEmailOptions.minDomainAtoms === &#039;undefined&#039; ||
            Hoek.isInteger(isEmailOptions.minDomainAtoms) &amp;&amp; isEmailOptions.minDomainAtoms &gt; 0,
            &#039;minDomainAtoms must be a positive integer&#039;);
        Hoek.assert(typeof isEmailOptions.errorLevel === &#039;undefined&#039; || typeof isEmailOptions.errorLevel === &#039;boolean&#039; ||
            (Hoek.isInteger(isEmailOptions.errorLevel) &amp;&amp; isEmailOptions.errorLevel &gt;= 0),
            &#039;errorLevel must be a non-negative integer or boolean&#039;);
    }

    return this._test(&#039;email&#039;, isEmailOptions, function (value, state, options) {

        try {
            var result = Isemail(value, isEmailOptions);
            if (result === true || result === 0) {
                return null;
            }
        }
        catch (e) {}

        return Errors.create(&#039;string.email&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.ip = function (ipOptions) {

    var regex = internals.ipRegex;
    ipOptions = ipOptions || {};
    Hoek.assert(typeof ipOptions === &#039;object&#039;, &#039;options must be an object&#039;);

    if (ipOptions.cidr) {
        Hoek.assert(typeof ipOptions.cidr === &#039;string&#039;, &#039;cidr must be a string&#039;);
        ipOptions.cidr = ipOptions.cidr.toLowerCase();

        Hoek.assert(ipOptions.cidr in Ip.cidrs, &#039;cidr must be one of &#039; + Object.keys(Ip.cidrs).join(&#039;, &#039;));

        // If we only received a `cidr` setting, create a regex for it. But we don&#039;t need to create one if `cidr` is &quot;optional&quot; since that is the default
        if (!ipOptions.version &amp;&amp; ipOptions.cidr !== &#039;optional&#039;) {
            regex = Ip.createIpRegex([&#039;ipv4&#039;, &#039;ipv6&#039;, &#039;ipvfuture&#039;], ipOptions.cidr);
        }
    }
    else {

        // Set our default cidr strategy
        ipOptions.cidr = &#039;optional&#039;;
    }

    if (ipOptions.version) {
        if (!Array.isArray(ipOptions.version)) {
            ipOptions.version = [ipOptions.version];
        }

        Hoek.assert(ipOptions.version.length &gt;= 1, &#039;version must have at least 1 version specified&#039;);

        var versions = [];
        for (var i = 0, il = ipOptions.version.length; i &lt; il; ++i) {
            var version = ipOptions.version[i];
            Hoek.assert(typeof version === &#039;string&#039;, &#039;version at position &#039; + i + &#039; must be a string&#039;);
            version = version.toLowerCase();
            Hoek.assert(Ip.versions[version], &#039;version at position &#039; + i + &#039; must be one of &#039; + Object.keys(Ip.versions).join(&#039;, &#039;));
            versions.push(version);
        }

        // Make sure we have a set of versions
        versions = Hoek.unique(versions);

        regex = Ip.createIpRegex(versions, ipOptions.cidr);
    }

    return this._test(&#039;ip&#039;, ipOptions, function (value, state, options) {

        if (regex.test(value)) {
            return null;
        }

        if (versions) {
            return Errors.create(&#039;string.ipVersion&#039;, { value: value, cidr: ipOptions.cidr, version: versions }, state, options);
        }

        return Errors.create(&#039;string.ip&#039;, { value: value, cidr: ipOptions.cidr }, state, options);
    });
};


internals.String.prototype.uri = function (uriOptions) {

    var customScheme = &#039;&#039;,
        regex = internals.uriRegex;

    if (uriOptions) {
        Hoek.assert(typeof uriOptions === &#039;object&#039;, &#039;options must be an object&#039;);

        if (uriOptions.scheme) {
            Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === &#039;string&#039; || Array.isArray(uriOptions.scheme), &#039;scheme must be a RegExp, String, or Array&#039;);

            if (!Array.isArray(uriOptions.scheme)) {
                uriOptions.scheme = [uriOptions.scheme];
            }

            Hoek.assert(uriOptions.scheme.length &gt;= 1, &#039;scheme must have at least 1 scheme specified&#039;);

            // Flatten the array into a string to be used to match the schemes.
            for (var i = 0, il = uriOptions.scheme.length; i &lt; il; ++i) {
                var scheme = uriOptions.scheme[i];
                Hoek.assert(scheme instanceof RegExp || typeof scheme === &#039;string&#039;, &#039;scheme at position &#039; + i + &#039; must be a RegExp or String&#039;);

                // Add OR separators if a value already exists
                customScheme += customScheme ? &#039;|&#039; : &#039;&#039;;

                // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don&#039;t escape their pattern unknowingly.
                if (scheme instanceof RegExp) {
                    customScheme += scheme.source;
                }
                else {
                    Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), &#039;scheme at position &#039; + i + &#039; must be a valid scheme&#039;);
                    customScheme += Hoek.escapeRegex(scheme);
                }
            }
        }
    }

    if (customScheme) {
        regex = Uri.createUriRegex(customScheme);
    }

    return this._test(&#039;uri&#039;, uriOptions, function (value, state, options) {

        if (regex.test(value)) {
            return null;
        }

        if (customScheme) {
            return Errors.create(&#039;string.uriCustomScheme&#039;, { scheme: customScheme, value: value }, state, options);
        }

        return Errors.create(&#039;string.uri&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.isoDate = function () {

    return this._test(&#039;isoDate&#039;, undefined, function (value, state, options) {

        if (JoiDate._isIsoDate(value)) {
            return null;
        }

        return Errors.create(&#039;string.isoDate&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.guid = function () {

    var regex = /^[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}$/i;
    var regex2 = /^\{[A-F0-9]{8}(?:-?[A-F0-9]{4}){3}-?[A-F0-9]{12}\}$/i;

    return this._test(&#039;guid&#039;, undefined, function (value, state, options) {

        if (regex.test(value) || regex2.test(value)) {
            return null;
        }

        return Errors.create(&#039;string.guid&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.hex = function () {

    var regex = /^[a-f0-9]+$/i;

    return this._test(&#039;hex&#039;, regex, function (value, state, options) {

        if (regex.test(value)) {
            return null;
        }

        return Errors.create(&#039;string.hex&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.hostname = function () {

    var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

    return this._test(&#039;hostname&#039;, undefined, function (value, state, options) {

        if ((value.length &lt;= 255 &amp;&amp; regex.test(value)) ||
            Net.isIPv6(value)) {

            return null;
        }

        return Errors.create(&#039;string.hostname&#039;, { value: value }, state, options);
    });
};


internals.String.prototype.lowercase = function () {

    var obj = this._test(&#039;lowercase&#039;, undefined, function (value, state, options) {

        if (options.convert ||
            value === value.toLocaleLowerCase()) {

            return null;
        }

        return Errors.create(&#039;string.lowercase&#039;, { value: value }, state, options);
    });

    obj._flags.case = &#039;lower&#039;;
    return obj;
};


internals.String.prototype.uppercase = function () {

    var obj = this._test(&#039;uppercase&#039;, undefined, function (value, state, options) {

        if (options.convert ||
            value === value.toLocaleUpperCase()) {

            return null;
        }

        return Errors.create(&#039;string.uppercase&#039;, { value: value }, state, options);
    });

    obj._flags.case = &#039;upper&#039;;
    return obj;
};


internals.String.prototype.trim = function () {

    var obj = this._test(&#039;trim&#039;, undefined, function (value, state, options) {

        if (options.convert ||
            value === value.trim()) {

            return null;
        }

        return Errors.create(&#039;string.trim&#039;, { value: value }, state, options);
    });

    obj._flags.trim = true;
    return obj;
};


internals.String.prototype.replace = function (pattern, replacement) {

    if (typeof pattern === &#039;string&#039;) {
        pattern = new RegExp(Hoek.escapeRegex(pattern), &#039;g&#039;);
    }

    Hoek.assert(pattern instanceof RegExp, &#039;pattern must be a RegExp&#039;);
    Hoek.assert(typeof replacement === &#039;string&#039;, &#039;replacement must be a String&#039;);

    // This can not be considere a test like trim, we can&#039;t &quot;reject&quot;
    // anything from this rule, so just clone the current object
    var obj = this.clone();

    if (!obj._inner.replacements) {
        obj._inner.replacements = [];
    }

    obj._inner.replacements.push({
        pattern: pattern,
        replacement: replacement
    });

    return obj;
};

module.exports = new internals.String();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
