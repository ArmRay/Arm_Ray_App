<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/hoek/test/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/hoek/test/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.76</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2513</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">121.71</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">35.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Fs = require(&#039;fs&#039;);
var Path = require(&#039;path&#039;);
var Code = require(&#039;code&#039;);
var Hoek = require(&#039;../lib&#039;);
var Lab = require(&#039;lab&#039;);


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.experiment;
var it = lab.test;
var expect = Code.expect;


var nestedObj = {
    v: [7, 8, 9],
    w: /^something$/igm,
    x: {
        a: [1, 2, 3],
        b: 123456,
        c: new Date(),
        d: /hi/igm,
        e: /hello/
    },
    y: &#039;y&#039;,
    z: new Date(1378775452757)
};

var dupsArray = [nestedObj, { z: &#039;z&#039; }, nestedObj];
var reducedDupsArray = [nestedObj, { z: &#039;z&#039; }];

describe(&#039;clone()&#039;, function () {

    it(&#039;clones a nested object&#039;, function (done) {

        var a = nestedObj;
        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        expect(a.z.getTime()).to.equal(b.z.getTime());
        done();
    });

    it(&#039;clones a null object&#039;, function (done) {

        var b = Hoek.clone(null);

        expect(b).to.equal(null);
        done();
    });

    it(&#039;should not convert undefined properties to null&#039;, function (done) {

        var obj = { something: undefined };
        var b = Hoek.clone(obj);

        expect(typeof b.something).to.equal(&#039;undefined&#039;);
        done();
    });

    it(&#039;should not throw on circular reference&#039;, function (done) {

        var a = {};
        a.x = a;

        var test = function () {

            var b = Hoek.clone(a);
        };

        expect(test).to.not.throw();
        done();
    });

    it(&#039;clones circular reference&#039;, function (done) {

        var x = {
            &#039;z&#039;: new Date()
        };
        x.y = x;

        var b = Hoek.clone(x);
        expect(Object.keys(b.y)).to.deep.equal(Object.keys(x));
        expect(b.z).to.not.equal(x.z);
        expect(b.y).to.not.equal(x.y);
        expect(b.y.z).to.not.equal(x.y.z);
        expect(b.y).to.equal(b);
        expect(b.y.y.y.y).to.equal(b);
        done();
    });

    it(&#039;clones an object with a null prototype&#039;, function (done) {

        var obj = Object.create(null);
        var b = Hoek.clone(obj);

        expect(b).to.deep.equal(obj);
        done();
    });

    it(&#039;clones deeply nested object&#039;, function (done) {

        var a = {
            x: {
                y: {
                    a: [1, 2, 3],
                    b: 123456,
                    c: new Date(),
                    d: /hi/igm,
                    e: /hello/
                }
            }
        };

        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        expect(a.x.y.c.getTime()).to.equal(b.x.y.c.getTime());
        done();
    });

    it(&#039;clones arrays&#039;, function (done) {

        var a = [1, 2, 3];

        var b = Hoek.clone(a);

        expect(a).to.deep.equal(b);
        done();
    });

    it(&#039;performs actual copy for shallow keys (no pass by reference)&#039;, function (done) {

        var x = Hoek.clone(nestedObj);
        var y = Hoek.clone(nestedObj);

        // Date
        expect(x.z).to.not.equal(nestedObj.z);
        expect(x.z).to.not.equal(y.z);

        // Regex
        expect(x.w).to.not.equal(nestedObj.w);
        expect(x.w).to.not.equal(y.w);

        // Array
        expect(x.v).to.not.equal(nestedObj.v);
        expect(x.v).to.not.equal(y.v);

        // Immutable(s)
        x.y = 5;
        expect(x.y).to.not.equal(nestedObj.y);
        expect(x.y).to.not.equal(y.y);

        done();
    });

    it(&#039;performs actual copy for deep keys (no pass by reference)&#039;, function (done) {

        var x = Hoek.clone(nestedObj);
        var y = Hoek.clone(nestedObj);

        expect(x.x.c).to.not.equal(nestedObj.x.c);
        expect(x.x.c).to.not.equal(y.x.c);

        expect(x.x.c.getTime()).to.equal(nestedObj.x.c.getTime());
        expect(x.x.c.getTime()).to.equal(y.x.c.getTime());
        done();
    });

    it(&#039;copies functions with properties&#039;, function (done) {

        var a = {
            x: function () {

                return 1;
            },
            y: {}
        };
        a.x.z = &#039;string in function&#039;;
        a.x.v = function () {

            return 2;
        };
        a.y.u = a.x;

        var b = Hoek.clone(a);
        expect(b.x()).to.equal(1);
        expect(b.x.v()).to.equal(2);
        expect(b.y.u).to.equal(b.x);
        expect(b.x.z).to.equal(&#039;string in function&#039;);
        done();
    });

    it(&#039;should copy a buffer&#039;, function (done) {

        var tls = {
            key: new Buffer([1, 2, 3, 4, 5]),
            cert: new Buffer([1, 2, 3, 4, 5, 6, 10])
        };

        var copiedTls = Hoek.clone(tls);
        expect(Buffer.isBuffer(copiedTls.key)).to.equal(true);
        expect(JSON.stringify(copiedTls.key)).to.equal(JSON.stringify(tls.key));
        expect(Buffer.isBuffer(copiedTls.cert)).to.equal(true);
        expect(JSON.stringify(copiedTls.cert)).to.equal(JSON.stringify(tls.cert));
        done();
    });

    it(&#039;clones an object with a prototype&#039;, function (done) {

        var Obj = function () {

            this.a = 5;
        };

        Obj.prototype.b = function () {

            return &#039;c&#039;;
        };

        var a = new Obj();
        var b = Hoek.clone(a);

        expect(b.a).to.equal(5);
        expect(b.b()).to.equal(&#039;c&#039;);
        expect(a).to.deep.equal(b);
        done();
    });

    it(&#039;reuses cloned Date object&#039;, function (done) {

        var obj = {
            a: new Date()
        };

        obj.b = obj.a;

        var copy = Hoek.clone(obj);
        expect(copy.a).to.equal(copy.b);
        done();
    });

    it(&#039;shallow copies an object with a prototype and isImmutable flag&#039;, function (done) {

        var Obj = function () {

            this.value = 5;
        };

        Obj.prototype.b = function () {

            return &#039;c&#039;;
        };

        Obj.prototype.isImmutable = true;

        var obj = {
            a: new Obj()
        };

        var copy = Hoek.clone(obj);

        expect(obj.a.value).to.equal(5);
        expect(copy.a.value).to.equal(5);
        expect(copy.a.b()).to.equal(&#039;c&#039;);
        expect(obj.a).to.equal(copy.a);
        done();
    });

    it(&#039;clones an object with property getter without executing it&#039;, function (done) {

        var obj = {};
        var value = 1;
        var execCount = 0;

        Object.defineProperty(obj, &#039;test&#039;, {
            enumerable: true,
            configurable: true,
            get: function () {

                ++execCount;
                return value;
            }
        });

        var copy = Hoek.clone(obj);
        expect(execCount).to.equal(0);
        expect(copy.test).to.equal(1);
        expect(execCount).to.equal(1);
        done();
    });

    it(&#039;clones an object with property getter and setter&#039;, function (done) {

        var obj = {
            _test: 0
        };

        Object.defineProperty(obj, &#039;test&#039;, {
            enumerable: true,
            configurable: true,
            get: function () {

                return this._test;
            },
            set: function (value) {

                this._test = value - 1;
            }
        });

        var copy = Hoek.clone(obj);
        expect(copy.test).to.equal(0);
        copy.test = 5;
        expect(copy.test).to.equal(4);
        done();
    });

    it(&#039;clones an object with only property setter&#039;, function (done) {

        var obj = {
            _test: 0
        };

        Object.defineProperty(obj, &#039;test&#039;, {
            enumerable: true,
            configurable: true,
            set: function (value) {

                this._test = value - 1;
            }
        });

        var copy = Hoek.clone(obj);
        expect(copy._test).to.equal(0);
        copy.test = 5;
        expect(copy._test).to.equal(4);
        done();
    });

    it(&#039;clones an object with non-enumerable properties&#039;, function (done) {

        var obj = {
            _test: 0
        };

        Object.defineProperty(obj, &#039;test&#039;, {
            enumerable: false,
            configurable: true,
            set: function (value) {

                this._test = value - 1;
            }
        });

        var copy = Hoek.clone(obj);
        expect(copy._test).to.equal(0);
        copy.test = 5;
        expect(copy._test).to.equal(4);
        done();
    });

    it(&#039;clones an object where getOwnPropertyDescriptor returns undefined&#039;, function (done) {

        var oldGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var obj = { a: &#039;b&#039; };
        Object.getOwnPropertyDescriptor = function () {

            return undefined;
        };

        var copy = Hoek.clone(obj);
        Object.getOwnPropertyDescriptor = oldGetOwnPropertyDescriptor;
        expect(copy).to.deep.equal(obj);
        done();
    });
});

describe(&#039;merge()&#039;, function () {

    it(&#039;deep copies source items&#039;, function (done) {

        var target = {
            b: 3,
            d: []
        };

        var source = {
            c: {
                d: 1
            },
            d: [{ e: 1 }]
        };

        Hoek.merge(target, source);
        expect(target.c).to.not.equal(source.c);
        expect(target.c).to.deep.equal(source.c);
        expect(target.d).to.not.equal(source.d);
        expect(target.d[0]).to.not.equal(source.d[0]);
        expect(target.d).to.deep.equal(source.d);
        done();
    });

    it(&#039;merges array over an object&#039;, function (done) {

        var a = {
            x: [&#039;n&#039;, &#039;m&#039;]
        };

        var b = {
            x: {
                n: &#039;1&#039;,
                m: &#039;2&#039;
            }
        };

        Hoek.merge(b, a);
        expect(a.x[0]).to.equal(&#039;n&#039;);
        expect(a.x.n).to.not.exist();
        done();
    });

    it(&#039;merges object over an array&#039;, function (done) {

        var a = {
            x: [&#039;n&#039;, &#039;m&#039;]
        };

        var b = {
            x: {
                n: &#039;1&#039;,
                m: &#039;2&#039;
            }
        };

        Hoek.merge(a, b);
        expect(a.x.n).to.equal(&#039;1&#039;);
        expect(a.x[0]).to.not.exist();
        done();
    });

    it(&#039;does not throw if source is null&#039;, function (done) {

        var a = {};
        var b = null;
        var c = null;

        expect(function () {

            c = Hoek.merge(a, b);
        }).to.not.throw();

        expect(c).to.equal(a);
        done();
    });

    it(&#039;does not throw if source is undefined&#039;, function (done) {

        var a = {};
        var b;
        var c = null;

        expect(function () {

            c = Hoek.merge(a, b);
        }).to.not.throw();

        expect(c).to.equal(a);
        done();
    });

    it(&#039;throws if source is not an object&#039;, function (done) {

        expect(function () {

            var a = {};
            var b = 0;

            Hoek.merge(a, b);
        }).to.throw(&#039;Invalid source value: must be null, undefined, or an object&#039;);
        done();
    });

    it(&#039;throws if target is not an object&#039;, function (done) {

        expect(function () {

            var a = 0;
            var b = {};

            Hoek.merge(a, b);
        }).to.throw(&#039;Invalid target value: must be an object&#039;);
        done();
    });

    it(&#039;throws if target is not an array and source is&#039;, function (done) {

        expect(function () {

            var a = {};
            var b = [1, 2];

            Hoek.merge(a, b);
        }).to.throw(&#039;Cannot merge array onto an object&#039;);
        done();
    });

    it(&#039;returns the same object when merging arrays&#039;, function (done) {

        var a = [];
        var b = [1, 2];

        expect(Hoek.merge(a, b)).to.equal(a);
        done();
    });

    it(&#039;combines an empty object with a non-empty object&#039;, function (done) {

        var a = {};
        var b = nestedObj;

        var c = Hoek.merge(a, b);
        expect(a).to.deep.equal(b);
        expect(c).to.deep.equal(b);
        done();
    });

    it(&#039;overrides values in target&#039;, function (done) {

        var a = { x: 1, y: 2, z: 3, v: 5, t: &#039;test&#039;, m: &#039;abc&#039; };
        var b = { x: null, z: 4, v: 0, t: { u: 6 }, m: &#039;123&#039; };

        var c = Hoek.merge(a, b);
        expect(c.x).to.equal(null);
        expect(c.y).to.equal(2);
        expect(c.z).to.equal(4);
        expect(c.v).to.equal(0);
        expect(c.m).to.equal(&#039;123&#039;);
        expect(c.t).to.deep.equal({ u: 6 });
        done();
    });

    it(&#039;overrides values in target (flip)&#039;, function (done) {

        var a = { x: 1, y: 2, z: 3, v: 5, t: &#039;test&#039;, m: &#039;abc&#039; };
        var b = { x: null, z: 4, v: 0, t: { u: 6 }, m: &#039;123&#039; };

        var d = Hoek.merge(b, a);
        expect(d.x).to.equal(1);
        expect(d.y).to.equal(2);
        expect(d.z).to.equal(3);
        expect(d.v).to.equal(5);
        expect(d.m).to.equal(&#039;abc&#039;);
        expect(d.t).to.deep.equal(&#039;test&#039;);
        done();
    });

    it(&#039;retains Date properties&#039;, function (done) {

        var a = { x: new Date(1378776452757) };

        var b = Hoek.merge({}, a);
        expect(a.x.getTime()).to.equal(b.x.getTime());
        done();
    });

    it(&#039;retains Date properties when merging keys&#039;, function (done) {

        var a = { x: new Date(1378776452757) };

        var b = Hoek.merge({ x: {} }, a);
        expect(a.x.getTime()).to.equal(b.x.getTime());
        done();
    });

    it(&#039;overrides Buffer&#039;, function (done) {

        var a = { x: new Buffer(&#039;abc&#039;) };

        var b = Hoek.merge({ x: {} }, a);
        expect(a.x.toString()).to.equal(&#039;abc&#039;);
        done();
    });
});

describe(&#039;applyToDefaults()&#039;, function () {

    var defaults = {
        a: 1,
        b: 2,
        c: {
            d: 3,
            e: [5, 6]
        },
        f: 6,
        g: &#039;test&#039;
    };

    it(&#039;throws when target is null&#039;, function (done) {

        expect(function () {

            Hoek.applyToDefaults(null, {});
        }).to.throw(&#039;Invalid defaults value: must be an object&#039;);
        done();
    });

    it(&#039;returns null if options is false&#039;, function (done) {

        var result = Hoek.applyToDefaults(defaults, false);
        expect(result).to.equal(null);
        done();
    });

    it(&#039;returns null if options is null&#039;, function (done) {

        var result = Hoek.applyToDefaults(defaults, null);
        expect(result).to.equal(null);
        done();
    });

    it(&#039;returns null if options is undefined&#039;, function (done) {

        var result = Hoek.applyToDefaults(defaults, undefined);
        expect(result).to.equal(null);
        done();
    });

    it(&#039;returns a copy of defaults if options is true&#039;, function (done) {

        var result = Hoek.applyToDefaults(defaults, true);
        expect(result).to.deep.equal(defaults);
        done();
    });

    it(&#039;applies object to defaults&#039;, function (done) {

        var obj = {
            a: null,
            c: {
                e: [4]
            },
            f: 0,
            g: {
                h: 5
            }
        };

        var result = Hoek.applyToDefaults(defaults, obj);
        expect(result.c.e).to.deep.equal([4]);
        expect(result.a).to.equal(1);
        expect(result.b).to.equal(2);
        expect(result.f).to.equal(0);
        expect(result.g).to.deep.equal({ h: 5 });
        done();
    });

    it(&#039;applies object to defaults with null&#039;, function (done) {

        var obj = {
            a: null,
            c: {
                e: [4]
            },
            f: 0,
            g: {
                h: 5
            }
        };

        var result = Hoek.applyToDefaults(defaults, obj, true);
        expect(result.c.e).to.deep.equal([4]);
        expect(result.a).to.equal(null);
        expect(result.b).to.equal(2);
        expect(result.f).to.equal(0);
        expect(result.g).to.deep.equal({ h: 5 });
        done();
    });
});

describe(&#039;cloneWithShallow()&#039;, function () {

    it(&#039;deep clones except for listed keys&#039;, function (done) {

        var source = {
            a: {
                b: 5
            },
            c: {
                d: 6
            }
        };

        var copy = Hoek.cloneWithShallow(source, [&#039;c&#039;]);
        expect(copy).to.deep.equal(source);
        expect(copy).to.not.equal(source);
        expect(copy.a).to.not.equal(source.a);
        expect(copy.b).to.equal(source.b);
        done();
    });

    it(&#039;returns immutable value&#039;, function (done) {

        expect(Hoek.cloneWithShallow(5)).to.equal(5);
        done();
    });

    it(&#039;returns null value&#039;, function (done) {

        expect(Hoek.cloneWithShallow(null)).to.equal(null);
        done();
    });

    it(&#039;returns undefined value&#039;, function (done) {

        expect(Hoek.cloneWithShallow(undefined)).to.equal(undefined);
        done();
    });

    it(&#039;deep clones except for listed keys (including missing keys)&#039;, function (done) {

        var source = {
            a: {
                b: 5
            },
            c: {
                d: 6
            }
        };

        var copy = Hoek.cloneWithShallow(source, [&#039;c&#039;, &#039;v&#039;]);
        expect(copy).to.deep.equal(source);
        expect(copy).to.not.equal(source);
        expect(copy.a).to.not.equal(source.a);
        expect(copy.b).to.equal(source.b);
        done();
    });
});

describe(&#039;applyToDefaultsWithShallow()&#039;, function () {

    it(&#039;shallow copies the listed keys from options without merging&#039;, function (done) {

        var defaults = {
            a: {
                b: 5,
                e: 3
            },
            c: {
                d: 7,
                g: 1
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                d: 6,
                f: 7
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, [&#039;a&#039;]);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { d: 6, g: 1, f: 7 } });
        expect(merged.a).to.equal(options.a);
        expect(merged.a).to.not.equal(defaults.a);
        expect(merged.c).to.not.equal(options.c);
        expect(merged.c).to.not.equal(defaults.c);
        done();
    });

    it(&#039;shallow copies the nested keys (override)&#039;, function (done) {

        var defaults = {
            a: {
                b: 5
            },
            c: {
                d: 7,
                g: 1
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                d: 6,
                g: {
                    h: 8
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, [&#039;c.g&#039;]);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { d: 6, g: { h: 8 } } });
        expect(merged.c.g).to.equal(options.c.g);
        done();
    });

    it(&#039;shallow copies the nested keys (missing)&#039;, function (done) {

        var defaults = {
            a: {
                b: 5
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    h: 8
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, [&#039;c.g&#039;]);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { h: 8 } } });
        expect(merged.c.g).to.equal(options.c.g);
        done();
    });

    it(&#039;shallow copies the nested keys (override)&#039;, function (done) {

        var defaults = {
            a: {
                b: 5
            },
            c: {
                g: {
                    d: 7
                }
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    h: 8
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, [&#039;c.g&#039;]);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { h: 8 } } });
        expect(merged.c.g).to.equal(options.c.g);
        done();
    });

    it(&#039;shallow copies the nested keys (deeper)&#039;, function (done) {

        var defaults = {
            a: {
                b: 5
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    r: {
                        h: 8
                    }
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, [&#039;c.g.r&#039;]);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });
        expect(merged.c.g.r).to.equal(options.c.g.r);
        done();
    });

    it(&#039;shallow copies the nested keys (not present)&#039;, function (done) {

        var defaults = {
            a: {
                b: 5
            }
        };

        var options = {
            a: {
                b: 4
            },
            c: {
                g: {
                    r: {
                        h: 8
                    }
                }
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, options, [&#039;x.y&#039;]);
        expect(merged).to.deep.equal({ a: { b: 4 }, c: { g: { r: { h: 8 } } } });
        done();
    });

    it(&#039;shallow copies the listed keys in the defaults&#039;, function (done) {

        var defaults = {
            a: {
                b: 1
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, {}, [&#039;a&#039;]);
        expect(merged.a).to.equal(defaults.a);
        done();
    });

    it(&#039;shallow copies the listed keys in the defaults (true)&#039;, function (done) {

        var defaults = {
            a: {
                b: 1
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, true, [&#039;a&#039;]);
        expect(merged.a).to.equal(defaults.a);
        done();
    });

    it(&#039;returns null on false&#039;, function (done) {

        var defaults = {
            a: {
                b: 1
            }
        };

        var merged = Hoek.applyToDefaultsWithShallow(defaults, false, [&#039;a&#039;]);
        expect(merged).to.equal(null);
        done();
    });

    it(&#039;throws on missing defaults&#039;, function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow(null, {}, [&#039;a&#039;]);
        }).to.throw(&#039;Invalid defaults value: must be an object&#039;);
        done();
    });

    it(&#039;throws on invalid defaults&#039;, function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow(&#039;abc&#039;, {}, [&#039;a&#039;]);
        }).to.throw(&#039;Invalid defaults value: must be an object&#039;);
        done();
    });

    it(&#039;throws on invalid options&#039;, function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow({}, &#039;abc&#039;, [&#039;a&#039;]);
        }).to.throw(&#039;Invalid options value: must be true, falsy or an object&#039;);
        done();
    });

    it(&#039;throws on missing keys&#039;, function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow({}, true);
        }).to.throw(&#039;Invalid keys&#039;);
        done();
    });

    it(&#039;throws on invalid keys&#039;, function (done) {

        expect(function () {

            Hoek.applyToDefaultsWithShallow({}, true, &#039;a&#039;);
        }).to.throw(&#039;Invalid keys&#039;);
        done();
    });
});

describe(&#039;deepEqual()&#039;, function () {

    it(&#039;compares simple values&#039;, function (done) {

        expect(Hoek.deepEqual(&#039;x&#039;, &#039;x&#039;)).to.be.true();
        expect(Hoek.deepEqual(&#039;x&#039;, &#039;y&#039;)).to.be.false();
        expect(Hoek.deepEqual(&#039;x1&#039;, &#039;x&#039;)).to.be.false();
        expect(Hoek.deepEqual(-0, +0)).to.be.false();
        expect(Hoek.deepEqual(-0, -0)).to.be.true();
        expect(Hoek.deepEqual(+0, +0)).to.be.true();
        expect(Hoek.deepEqual(+0, -0)).to.be.false();
        expect(Hoek.deepEqual(1, 1)).to.be.true();
        expect(Hoek.deepEqual(0, 0)).to.be.true();
        expect(Hoek.deepEqual(-1, 1)).to.be.false();
        expect(Hoek.deepEqual(NaN, 0)).to.be.false();
        expect(Hoek.deepEqual(NaN, NaN)).to.be.true();
        done();
    });

    it(&#039;compares different types&#039;, function (done) {

        expect(Hoek.deepEqual([], 5)).to.be.false();
        expect(Hoek.deepEqual(5, [])).to.be.false();
        expect(Hoek.deepEqual({}, null)).to.be.false();
        expect(Hoek.deepEqual(null, {})).to.be.false();
        expect(Hoek.deepEqual(&#039;abc&#039;, {})).to.be.false();
        expect(Hoek.deepEqual({}, &#039;abc&#039;)).to.be.false();
        done();
    });

    it(&#039;compares empty structures&#039;, function (done) {

        expect(Hoek.deepEqual([], [])).to.be.true();
        expect(Hoek.deepEqual({}, {})).to.be.true();
        expect(Hoek.deepEqual([], {})).to.be.false();
        done();
    });

    it(&#039;compares empty arguments object&#039;, function (done) {

        var compare = function () {

            expect(Hoek.deepEqual([], arguments)).to.be.false();
        };

        compare();
        done();
    });

    it(&#039;compares empty arguments objects&#039;, function (done) {

        var compare = function () {

            var arg1 = arguments;

            var inner = function () {

                expect(Hoek.deepEqual(arg1, arguments)).to.be.false(); // callee is not the same
            };

            inner();
        };

        compare();
        done();
    });

    it(&#039;compares dates&#039;, function (done) {

        expect(Hoek.deepEqual(new Date(2015, 1, 1), new Date(2015, 1, 1))).to.be.true();
        expect(Hoek.deepEqual(new Date(100), new Date(101))).to.be.false();
        expect(Hoek.deepEqual(new Date(), {})).to.be.false();
        done();
    });

    it(&#039;compares regular expressions&#039;, function (done) {

        expect(Hoek.deepEqual(/\s/, new RegExp(&#039;\\\s&#039;))).to.be.true();
        expect(Hoek.deepEqual(/\s/g, /\s/g)).to.be.true();
        expect(Hoek.deepEqual(/a/, {})).to.be.false();
        expect(Hoek.deepEqual(/\s/g, /\s/i)).to.be.false();
        expect(Hoek.deepEqual(/a/g, /b/g)).to.be.false();
        done();
    });

    it(&#039;compares arrays&#039;, function (done) {

        expect(Hoek.deepEqual([[1]], [[1]])).to.be.true();
        expect(Hoek.deepEqual([1, 2, 3], [1, 2, 3])).to.be.true();
        expect(Hoek.deepEqual([1, 2, 3], [1, 3, 2])).to.be.false();
        expect(Hoek.deepEqual([1, 2, 3], [1, 2])).to.be.false();
        expect(Hoek.deepEqual([1], [1])).to.be.true();
        done();
    });

    it(&#039;compares buffers&#039;, function (done) {

        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), new Buffer([1, 2, 3]))).to.be.true();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), new Buffer([1, 3, 2]))).to.be.false();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), new Buffer([1, 2]))).to.be.false();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), {})).to.be.false();
        expect(Hoek.deepEqual(new Buffer([1, 2, 3]), [1, 2, 3])).to.be.false();
        done();
    });

    it(&#039;compares objects&#039;, function (done) {

        expect(Hoek.deepEqual({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 })).to.be.true();
        expect(Hoek.deepEqual({ foo: &#039;bar&#039; }, { foo: &#039;baz&#039; })).to.be.false();
        expect(Hoek.deepEqual({ foo: { bar: &#039;foo&#039; } }, { foo: { bar: &#039;baz&#039; } })).to.be.false();
        done();
    });

    it(&#039;handles circular dependency&#039;, function (done) {

        var a = {};
        a.x = a;

        var b = Hoek.clone(a);
        expect(Hoek.deepEqual(a, b)).to.be.true();
        done();
    });

    it(&#039;compares an object with property getter without executing it&#039;, function (done) {

        var obj = {};
        var value = 1;
        var execCount = 0;

        Object.defineProperty(obj, &#039;test&#039;, {
            enumerable: true,
            configurable: true,
            get: function () {

                ++execCount;
                return value;
            }
        });

        var copy = Hoek.clone(obj);
        expect(Hoek.deepEqual(obj, copy)).to.be.true();
        expect(execCount).to.equal(0);
        expect(copy.test).to.equal(1);
        expect(execCount).to.equal(1);
        done();
    });

    it(&#039;compares objects with property getters&#039;, function (done) {

        var obj = {};
        Object.defineProperty(obj, &#039;test&#039;, {
            enumerable: true,
            configurable: true,
            get: function () {

                return 1;
            }
        });

        var ref = {};
        Object.defineProperty(ref, &#039;test&#039;, {
            enumerable: true,
            configurable: true,
            get: function () {

                return 2;
            }
        });

        expect(Hoek.deepEqual(obj, ref)).to.be.false();
        done();
    });

    it(&#039;compares object prototypes&#039;, function (done) {

        var Obj = function () {

            this.a = 5;
        };

        Obj.prototype.b = function () {

            return this.a;
        };

        var Ref = function () {

            this.a = 5;
        };

        Ref.prototype.b = function () {

            return this.a;
        };

        expect(Hoek.deepEqual(new Obj(), new Ref())).to.be.false();
        expect(Hoek.deepEqual(new Obj(), new Obj())).to.be.true();
        expect(Hoek.deepEqual(new Ref(), new Ref())).to.be.true();
        done();
    });

    it(&#039;compares plain objects&#039;, function (done) {

        var a = Object.create(null);
        var b = Object.create(null);

        a.b = &#039;c&#039;;
        b.b = &#039;c&#039;;

        expect(Hoek.deepEqual(a, b)).to.be.true();
        expect(Hoek.deepEqual(a, { b: &#039;c&#039; })).to.be.false();
        done();
    });

    it(&#039;compares an object with an empty object&#039;, function (done) {

        var a = { a: 1, b: 2 };

        expect(Hoek.deepEqual({}, a)).to.be.false();
        expect(Hoek.deepEqual(a, {})).to.be.false();
        done();
    });

    it(&#039;compares an object ignoring the prototype&#039;, function (done) {

        var a = Object.create(null);
        var b = {};

        expect(Hoek.deepEqual(a, b, { prototype: false })).to.be.true();
        done();
    });

    it(&#039;compares an object ignoring the prototype recursively&#039;, function (done) {

        var a = [Object.create(null)];
        var b = [{}];

        expect(Hoek.deepEqual(a, b, { prototype: false })).to.be.true();
        done();
    });
});

describe(&#039;unique()&#039;, function () {

    it(&#039;ensures uniqueness within array of objects based on subkey&#039;, function (done) {

        var a = Hoek.unique(dupsArray, &#039;x&#039;);
        expect(a).to.deep.equal(reducedDupsArray);
        done();
    });

    it(&#039;removes duplicated without key&#039;, function (done) {

        expect(Hoek.unique([1, 2, 3, 4, 2, 1, 5])).to.deep.equal([1, 2, 3, 4, 5]);
        done();
    });
});

describe(&#039;mapToObject()&#039;, function () {

    it(&#039;returns null on null array&#039;, function (done) {

        var a = Hoek.mapToObject(null);
        expect(a).to.equal(null);
        done();
    });

    it(&#039;converts basic array to existential object&#039;, function (done) {

        var keys = [1, 2, 3, 4];
        var a = Hoek.mapToObject(keys);
        for (var i in keys) {
            expect(a[keys[i]]).to.equal(true);
        }
        done();
    });

    it(&#039;converts array of objects to existential object&#039;, function (done) {

        var keys = [{ x: 1 }, { x: 2 }, { x: 3 }, { y: 4 }];
        var subkey = &#039;x&#039;;
        var a = Hoek.mapToObject(keys, subkey);
        expect(a).to.deep.equal({ 1: true, 2: true, 3: true });
        done();
    });
});

describe(&#039;intersect()&#039;, function () {

    it(&#039;returns the common objects of two arrays&#039;, function (done) {

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [5, 4, 5, 6, 7];
        var common = Hoek.intersect(array1, array2);
        expect(common.length).to.equal(2);
        done();
    });

    it(&#039;returns just the first common object of two arrays&#039;, function (done) {

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [5, 4, 5, 6, 7];
        var common = Hoek.intersect(array1, array2, true);
        expect(common).to.equal(5);
        done();
    });

    it(&#039;returns null when no common and returning just the first common object of two arrays&#039;, function (done) {

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [6, 7];
        var common = Hoek.intersect(array1, array2, true);
        expect(common).to.equal(null);
        done();
    });

    it(&#039;returns an empty array if either input is null&#039;, function (done) {

        expect(Hoek.intersect([1], null).length).to.equal(0);
        expect(Hoek.intersect(null, [1]).length).to.equal(0);
        done();
    });

    it(&#039;returns the common objects of object and array&#039;, function (done) {

        var array1 = [1, 2, 3, 4, 4, 5, 5];
        var array2 = [5, 4, 5, 6, 7];
        var common = Hoek.intersect(Hoek.mapToObject(array1), array2);
        expect(common.length).to.equal(2);
        done();
    });
});

describe(&#039;contain()&#039;, function () {

    it(&#039;tests strings&#039;, function (done) {

        expect(Hoek.contain(&#039;abc&#039;, &#039;ab&#039;)).to.be.true();
        expect(Hoek.contain(&#039;abc&#039;, &#039;abc&#039;, { only: true })).to.be.true();
        expect(Hoek.contain(&#039;aaa&#039;, &#039;a&#039;, { only: true })).to.be.true();
        expect(Hoek.contain(&#039;abc&#039;, &#039;b&#039;, { once: true })).to.be.true();
        expect(Hoek.contain(&#039;abc&#039;, [&#039;a&#039;, &#039;c&#039;])).to.be.true();
        expect(Hoek.contain(&#039;abc&#039;, [&#039;a&#039;, &#039;d&#039;], { part: true })).to.be.true();

        expect(Hoek.contain(&#039;abc&#039;, &#039;ac&#039;)).to.be.false();
        expect(Hoek.contain(&#039;abcd&#039;, &#039;abc&#039;, { only: true })).to.be.false();
        expect(Hoek.contain(&#039;aab&#039;, &#039;a&#039;, { only: true })).to.be.false();
        expect(Hoek.contain(&#039;abb&#039;, &#039;b&#039;, { once: true })).to.be.false();
        expect(Hoek.contain(&#039;abc&#039;, [&#039;a&#039;, &#039;d&#039;])).to.be.false();
        expect(Hoek.contain(&#039;abc&#039;, [&#039;ab&#039;, &#039;bc&#039;])).to.be.false();                      // Overlapping values not supported
        done();
    });

    it(&#039;tests arrays&#039;, function (done) {

        expect(Hoek.contain([1, 2, 3], 1)).to.be.true();
        expect(Hoek.contain([{ a: 1 }], { a: 1 }, { deep: true })).to.be.true();
        expect(Hoek.contain([1, 2, 3], [1, 2])).to.be.true();
        expect(Hoek.contain([{ a: 1 }], [{ a: 1 }], { deep: true })).to.be.true();
        expect(Hoek.contain([1, 1, 2], [1, 2], { only: true })).to.be.true();
        expect(Hoek.contain([1, 2], [1, 2], { once: true })).to.be.true();
        expect(Hoek.contain([1, 2, 3], [1, 4], { part: true })).to.be.true();
        expect(Hoek.contain([[1], [2]], [[1]], { deep: true })).to.be.true();

        expect(Hoek.contain([1, 2, 3], 4)).to.be.false();
        expect(Hoek.contain([{ a: 1 }], { a: 2 }, { deep: true })).to.be.false();
        expect(Hoek.contain([{ a: 1 }], { a: 1 })).to.be.false();
        expect(Hoek.contain([1, 2, 3], [4, 5])).to.be.false();
        expect(Hoek.contain([[3], [2]], [[1]])).to.be.false();
        expect(Hoek.contain([[1], [2]], [[1]])).to.be.false();
        expect(Hoek.contain([{ a: 1 }], [{ a: 2 }], { deep: true })).to.be.false();
        expect(Hoek.contain([1, 3, 2], [1, 2], { only: true })).to.be.false();
        expect(Hoek.contain([1, 2, 2], [1, 2], { once: true })).to.be.false();
        expect(Hoek.contain([0, 2, 3], [1, 4], { part: true })).to.be.false();
        done();
    });

    it(&#039;tests objects&#039;, function (done) {

        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, &#039;a&#039;)).to.be.true();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, [&#039;a&#039;, &#039;c&#039;])).to.be.true();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], { only: true })).to.be.true();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1 })).to.be.true();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, c: 3 })).to.be.true();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 4 }, { part: true })).to.be.true();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, b: 2, c: 3 }, { only: true })).to.be.true();
        expect(Hoek.contain({ a: [1], b: [2], c: [3] }, { a: [1], c: [3] }, { deep: true })).to.be.true();
        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true })).to.be.true();
        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, part: true })).to.be.true();
        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, part: false })).to.be.false();
        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, only: true })).to.be.false();
        expect(Hoek.contain({ a: [{ b: 1 }, { c: 2 }, { d: 3, e: 4 }] }, { a: [{ b: 1 }, { d: 3 }] }, { deep: true, only: false })).to.be.true();

        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, &#039;d&#039;)).to.be.false();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, [&#039;a&#039;, &#039;d&#039;])).to.be.false();
        expect(Hoek.contain({ a: 1, b: 2, c: 3, d: 4 }, [&#039;a&#039;, &#039;b&#039;, &#039;c&#039;], { only: true })).to.be.false();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 2 })).to.be.false();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 2, b: 2 }, { part: true })).to.be.false();             // part does not ignore bad value
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 3 })).to.be.false();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, d: 4 })).to.be.false();
        expect(Hoek.contain({ a: 1, b: 2, c: 3 }, { a: 1, b: 2 }, { only: true })).to.be.false();
        expect(Hoek.contain({ a: [1], b: [2], c: [3] }, { a: [1], c: [3] })).to.be.false();
        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } })).to.be.false();
        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true })).to.be.true();
        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, only: true })).to.be.false();
        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, only: false })).to.be.true();
        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, part: true })).to.be.true();
        expect(Hoek.contain({ a: { b: { c: 1, d: 2 } } }, { a: { b: { c: 1 } } }, { deep: true, part: false })).to.be.false();

        // Getter check
        var Foo = function (bar) {

            this.bar = bar;
        };

        Object.defineProperty(Foo.prototype, &#039;baz&#039;, {
            enumerable: true,
            get: function () {

                return this.bar;
            }
        });

        expect(Hoek.contain({ a: new Foo(&#039;b&#039;) }, { a: new Foo(&#039;b&#039;) }, { deep: true })).to.be.true();
        expect(Hoek.contain({ a: new Foo(&#039;b&#039;) }, { a: new Foo(&#039;b&#039;) }, { deep: true, part: true })).to.be.true();
        expect(Hoek.contain({ a: new Foo(&#039;b&#039;) }, { a: { baz: &#039;b&#039; } }, { deep: true })).to.be.true();
        expect(Hoek.contain({ a: new Foo(&#039;b&#039;) }, { a: { baz: &#039;b&#039; } }, { deep: true, only: true })).to.be.false();
        expect(Hoek.contain({ a: new Foo(&#039;b&#039;) }, { a: { baz: &#039;b&#039; } }, { deep: true, part: false })).to.be.false();
        expect(Hoek.contain({ a: new Foo(&#039;b&#039;) }, { a: { baz: &#039;b&#039; } }, { deep: true, part: true })).to.be.true();

        done();
    });
});

describe(&#039;flatten()&#039;, function () {

    it(&#039;returns a flat array&#039;, function (done) {

        var result = Hoek.flatten([1, 2, [3, 4, [5, 6], [7], 8], [9], [10, [11, 12]], 13]);
        expect(result.length).to.equal(13);
        expect(result).to.deep.equal([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
        done();
    });
});

describe(&#039;reach()&#039;, function () {

    var obj = {
        a: {
            b: {
                c: {
                    d: 1,
                    e: 2
                },
                f: &#039;hello&#039;
            },
            g: {
                h: 3
            }
        },
        i: function () { },
        j: null,
        k: [4, 8, 9, 1]
    };

    obj.i.x = 5;

    it(&#039;returns object itself&#039;, function (done) {

        expect(Hoek.reach(obj, null)).to.equal(obj);
        expect(Hoek.reach(obj, false)).to.equal(obj);
        expect(Hoek.reach(obj)).to.equal(obj);
        done();
    });

    it(&#039;returns first value of array&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;k.0&#039;)).to.equal(4);
        done();
    });

    it(&#039;returns last value of array using negative index&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;k.-2&#039;)).to.equal(9);
        done();
    });

    it(&#039;returns a valid member&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;a.b.c.d&#039;)).to.equal(1);
        done();
    });

    it(&#039;returns a valid member with separator override&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;a/b/c/d&#039;, &#039;/&#039;)).to.equal(1);
        done();
    });

    it(&#039;returns undefined on null object&#039;, function (done) {

        expect(Hoek.reach(null, &#039;a.b.c.d&#039;)).to.equal(undefined);
        done();
    });

    it(&#039;returns undefined on missing object member&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;a.b.c.d.x&#039;)).to.equal(undefined);
        done();
    });

    it(&#039;returns undefined on missing function member&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;i.y&#039;, { functions: true })).to.equal(undefined);
        done();
    });

    it(&#039;throws on missing member in strict mode&#039;, function (done) {

        expect(function () {

            Hoek.reach(obj, &#039;a.b.c.o.x&#039;, { strict: true });
        }).to.throw(&#039;Missing segment o in reach path  a.b.c.o.x&#039;);

        done();
    });

    it(&#039;returns undefined on invalid member&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;a.b.c.d-.x&#039;)).to.equal(undefined);
        done();
    });

    it(&#039;returns function member&#039;, function (done) {

        expect(typeof Hoek.reach(obj, &#039;i&#039;)).to.equal(&#039;function&#039;);
        done();
    });

    it(&#039;returns function property&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;i.x&#039;)).to.equal(5);
        done();
    });

    it(&#039;returns null&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;j&#039;)).to.equal(null);
        done();
    });

    it(&#039;throws on function property when functions not allowed&#039;, function (done) {

        expect(function () {

            Hoek.reach(obj, &#039;i.x&#039;, { functions: false });
        }).to.throw(&#039;Invalid segment x in reach path  i.x&#039;);

        done();
    });

    it(&#039;will return a default value if property is not found&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;a.b.q&#039;, { default: &#039;defaultValue&#039; })).to.equal(&#039;defaultValue&#039;);
        done();
    });

    it(&#039;will return a default value if path is not found&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;q&#039;, { default: &#039;defaultValue&#039; })).to.equal(&#039;defaultValue&#039;);
        done();
    });

    it(&#039;allows a falsey value to be used as the default value&#039;, function (done) {

        expect(Hoek.reach(obj, &#039;q&#039;, { default: &#039;&#039; })).to.equal(&#039;&#039;);
        done();
    });
});

describe(&#039;reachTemplate()&#039;, function () {

    it(&#039;applies object to template&#039;, function (done) {

        var obj = {
            a: {
                b: {
                    c: {
                        d: 1
                    }
                }
            },
            j: null,
            k: [4, 8, 9, 1]
        };

        var template = &#039;{k.0}:{k.-2}:{a.b.c.d}:{x.y}:{j}&#039;;

        expect(Hoek.reachTemplate(obj, template)).to.equal(&#039;4:9:1::&#039;);
        done();
    });

    it(&#039;applies object to template (options)&#039;, function (done) {

        var obj = {
            a: {
                b: {
                    c: {
                        d: 1
                    }
                }
            },
            j: null,
            k: [4, 8, 9, 1]
        };

        var template = &#039;{k/0}:{k/-2}:{a/b/c/d}:{x/y}:{j}&#039;;

        expect(Hoek.reachTemplate(obj, template, &#039;/&#039;)).to.equal(&#039;4:9:1::&#039;);
        done();
    });
});

describe(&#039;callStack()&#039;, function () {

    it(&#039;returns the full call stack&#039;, function (done) {

        var stack = Hoek.callStack();
        expect(stack[0][0]).to.contain(&#039;index.js&#039;);
        expect(stack[0][2]).to.equal(26);
        done();
    });
});

describe(&#039;displayStack ()&#039;, function () {

    it(&#039;returns the full call stack for display&#039;, function (done) {

        var stack = Hoek.displayStack();
        expect(stack[0]).to.contain(Path.normalize(&#039;/test/index.js&#039;) + &#039;:&#039;);
        done();
    });

    it(&#039;includes constructor functions correctly&#039;, function (done) {

        var Something = function (next) {

            next();
        };

        var something = new Something(function () {

            var stack = Hoek.displayStack();
            expect(stack[1]).to.contain(&#039;new Something&#039;);
            done();
        });
    });
});

describe(&#039;abort()&#039;, function () {

    it(&#039;exits process when not in test mode&#039;, function (done) {

        var env = process.env.NODE_ENV;
        var write = process.stdout.write;
        var exit = process.exit;

        process.env.NODE_ENV = &#039;nottatest&#039;;
        process.stdout.write = function () { };
        process.exit = function (state) {

            process.exit = exit;
            process.env.NODE_ENV = env;
            process.stdout.write = write;

            expect(state).to.equal(1);
            done();
        };

        Hoek.abort(&#039;Boom&#039;);
    });

    it(&#039;throws when not in test mode and abortThrow is true&#039;, function (done) {

        var env = process.env.NODE_ENV;
        process.env.NODE_ENV = &#039;nottatest&#039;;
        Hoek.abortThrow = true;

        var fn = function () {

            Hoek.abort(&#039;my error message&#039;);
        };

        expect(fn).to.throw(&#039;my error message&#039;);
        Hoek.abortThrow = false;
        process.env.NODE_ENV = env;

        done();
    });

    it(&#039;respects hideStack argument&#039;, function (done) {

        var env = process.env.NODE_ENV;
        var write = process.stdout.write;
        var exit = process.exit;
        var output = &#039;&#039;;

        process.exit = function () { };
        process.env.NODE_ENV = &#039;&#039;;
        process.stdout.write = function (message) {

            output = message;
        };

        Hoek.abort(&#039;my error message&#039;, true);

        process.env.NODE_ENV = env;
        process.stdout.write = write;
        process.exit = exit;

        expect(output).to.equal(&#039;ABORT: my error message\n\t\n&#039;);

        done();
    });

    it(&#039;throws in test mode&#039;, function (done) {

        var env = process.env.NODE_ENV;
        process.env.NODE_ENV = &#039;test&#039;;

        expect(function () {

            Hoek.abort(&#039;my error message&#039;, true);
        }).to.throw(&#039;my error message&#039;);

        process.env.NODE_ENV = env;
        done();
    });

    it(&#039;throws in test mode with default message&#039;, function (done) {

        var env = process.env.NODE_ENV;
        process.env.NODE_ENV = &#039;test&#039;;

        expect(function () {

            Hoek.abort(&#039;&#039;, true);
        }).to.throw(&#039;Unknown error&#039;);

        process.env.NODE_ENV = env;
        done();
    });

    it(&#039;defaults to showing stack&#039;, function (done) {

        var env = process.env.NODE_ENV;
        var write = process.stdout.write;
        var exit = process.exit;
        var output = &#039;&#039;;

        process.exit = function () { };
        process.env.NODE_ENV = &#039;&#039;;
        process.stdout.write = function (message) {

            output = message;
        };

        Hoek.abort(&#039;my error message&#039;);

        process.env.NODE_ENV = env;
        process.stdout.write = write;
        process.exit = exit;

        expect(output).to.contain(&#039;index.js&#039;);

        done();
    });
});

describe(&#039;assert()&#039;, function () {

    it(&#039;throws an Error when using assert in a test&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false, &#039;my error message&#039;);
        };

        expect(fn).to.throw(&#039;my error message&#039;);
        done();
    });

    it(&#039;throws an Error when using assert in a test with no message&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false);
        };

        expect(fn).to.throw(&#039;Unknown error&#039;);
        done();
    });

    it(&#039;throws an Error when using assert in a test with multipart message&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false, &#039;This&#039;, &#039;is&#039;, &#039;my message&#039;);
        };

        expect(fn).to.throw(&#039;This is my message&#039;);
        done();
    });

    it(&#039;throws an Error when using assert in a test with multipart message (empty)&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false, &#039;This&#039;, &#039;is&#039;, &#039;&#039;, &#039;my message&#039;);
        };

        expect(fn).to.throw(&#039;This is my message&#039;);
        done();
    });

    it(&#039;throws an Error when using assert in a test with object message&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false, &#039;This&#039;, &#039;is&#039;, { spinal: &#039;tap&#039; });
        };

        expect(fn).to.throw(&#039;This is {&quot;spinal&quot;:&quot;tap&quot;}&#039;);
        done();
    });

    it(&#039;throws an Error when using assert in a test with multipart string and error messages&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false, &#039;This&#039;, &#039;is&#039;, new Error(&#039;spinal&#039;), new Error(&#039;tap&#039;));
        };

        expect(fn).to.throw(&#039;This is spinal tap&#039;);
        done();
    });

    it(&#039;throws an Error when using assert in a test with error object message&#039;, function (done) {

        var fn = function () {

            Hoek.assert(false, new Error(&#039;This is spinal tap&#039;));
        };

        expect(fn).to.throw(&#039;This is spinal tap&#039;);
        done();
    });

    it(&#039;throws the same Error that is passed to it if there is only one error passed&#039;, function (done) {

        var error = new Error(&#039;ruh roh&#039;);
        var error2 = new Error(&#039;ruh roh&#039;);

        var fn = function () {

            Hoek.assert(false, error);
        };

        try {
            fn();
        } catch (err) {
            expect(error).to.equal(error);  // should be the same reference
            expect(error).to.not.equal(error2); // error with the same message should not match
        }

        done();
    });
});

describe(&#039;Timer&#039;, function () {

    it(&#039;returns time elapsed&#039;, function (done) {

        var timer = new Hoek.Timer();
        setTimeout(function () {

            expect(timer.elapsed()).to.be.above(9);
            done();
        }, 12);
    });
});

describe(&#039;Bench&#039;, function () {

    it(&#039;returns time elapsed&#039;, function (done) {

        var timer = new Hoek.Bench();
        setTimeout(function () {

            expect(timer.elapsed()).to.be.above(9);
            done();
        }, 12);
    });
});

describe(&#039;escapeRegex()&#039;, function () {

    it(&#039;escapes all special regular expression characters&#039;, function (done) {

        var a = Hoek.escapeRegex(&#039;4^f$s.4*5+-_?%=#!:@|~\\/`&quot;(&gt;)[&lt;]d{}s,&#039;);
        expect(a).to.equal(&#039;4\\^f\\$s\\.4\\*5\\+\\-_\\?%\\=#\\!\\:@\\|~\\\\\\/`&quot;\\(&gt;\\)\\[&lt;\\]d\\{\\}s\\,&#039;);
        done();
    });
});

describe(&#039;Base64Url&#039;, function () {

    var base64str = &#039;AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0-P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn-AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq-wsbKztLW2t7i5uru8vb6_wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t_g4eLj5OXm5-jp6uvs7e7v8PHy8_T19vf4-fr7_P3-_w&#039;;
    var str = unescape(&#039;%00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29*+%2C-./0123456789%3A%3B%3C%3D%3E%3F@ABCDEFGHIJKLMNOPQRSTUVWXYZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF&#039;);

    describe(&#039;base64urlEncode()&#039;, function () {

        it(&#039;should base64 URL-safe a string&#039;, function (done) {

            expect(Hoek.base64urlEncode(str)).to.equal(base64str);
            done();
        });

        it(&#039;encodes a buffer&#039;, function (done) {

            expect(Hoek.base64urlEncode(new Buffer(str, &#039;binary&#039;))).to.equal(base64str);
            done();
        });

        it(&#039;should base64 URL-safe a hex string&#039;, function (done) {

            var buffer = new Buffer(str, &#039;binary&#039;);
            expect(Hoek.base64urlEncode(buffer.toString(&#039;hex&#039;), &#039;hex&#039;)).to.equal(base64str);
            done();
        });

        it(&#039;works on larger input strings&#039;, function (done) {

            var input = Fs.readFileSync(Path.join(__dirname, &#039;index.js&#039;)).toString();
            var encoded = Hoek.base64urlEncode(input);

            expect(encoded).to.not.contain(&#039;+&#039;);
            expect(encoded).to.not.contain(&#039;/&#039;);

            var decoded = Hoek.base64urlDecode(encoded);

            expect(decoded).to.equal(input);
            done();
        });
    });

    describe(&#039;base64urlDecode()&#039;, function () {

        it(&#039;should un-base64 URL-safe a string&#039;, function (done) {

            expect(Hoek.base64urlDecode(base64str)).to.equal(str);
            done();
        });

        it(&#039;should un-base64 URL-safe a string into hex&#039;, function (done) {

            expect(Hoek.base64urlDecode(base64str, &#039;hex&#039;)).to.equal(new Buffer(str, &#039;binary&#039;).toString(&#039;hex&#039;));
            done();
        });

        it(&#039;should un-base64 URL-safe a string and return a buffer&#039;, function (done) {

            var buf = Hoek.base64urlDecode(base64str, &#039;buffer&#039;);
            expect(buf instanceof Buffer).to.equal(true);
            expect(buf.toString(&#039;binary&#039;)).to.equal(str);
            done();
        });

        it(&#039;returns error on undefined input&#039;, function (done) {

            expect(Hoek.base64urlDecode().message).to.exist();
            done();
        });

        it(&#039;returns error on invalid input&#039;, function (done) {

            expect(Hoek.base64urlDecode(&#039;*&#039;).message).to.exist();
            done();
        });
    });
});

describe(&#039;escapeHeaderAttribute()&#039;, function () {

    it(&#039;should not alter ascii values&#039;, function (done) {

        var a = Hoek.escapeHeaderAttribute(&#039;My Value&#039;);
        expect(a).to.equal(&#039;My Value&#039;);
        done();
    });

    it(&#039;escapes all special HTTP header attribute characters&#039;, function (done) {

        var a = Hoek.escapeHeaderAttribute(&#039;I said go!!!#&quot;&#039; + String.fromCharCode(92));
        expect(a).to.equal(&#039;I said go!!!#\\&quot;\\\\&#039;);
        done();
    });

    it(&#039;throws on large unicode characters&#039;, function (done) {

        var fn = function () {

            Hoek.escapeHeaderAttribute(&#039;this is a test&#039; + String.fromCharCode(500) + String.fromCharCode(300));
        };

        expect(fn).to.throw(Error);
        done();
    });

    it(&#039;throws on CRLF to prevent response splitting&#039;, function (done) {

        var fn = function () {

            Hoek.escapeHeaderAttribute(&#039;this is a test\r\n&#039;);
        };

        expect(fn).to.throw(Error);
        done();
    });
});

describe(&#039;escapeHtml()&#039;, function () {

    it(&#039;escapes all special HTML characters&#039;, function (done) {

        var a = Hoek.escapeHtml(&#039;&amp;&lt;&gt;&quot;\&#039;`&#039;);
        expect(a).to.equal(&#039;&amp;amp;&amp;lt;&amp;gt;&amp;quot;&amp;#x27;&amp;#x60;&#039;);
        done();
    });

    it(&#039;returns empty string on falsy input&#039;, function (done) {

        var a = Hoek.escapeHtml(&#039;&#039;);
        expect(a).to.equal(&#039;&#039;);
        done();
    });

    it(&#039;returns unchanged string on no reserved input&#039;, function (done) {

        var a = Hoek.escapeHtml(&#039;abc&#039;);
        expect(a).to.equal(&#039;abc&#039;);
        done();
    });
});

describe(&#039;nextTick()&#039;, function () {

    it(&#039;calls the provided callback on nextTick&#039;, function (done) {

        var a = 0;

        var inc = function (step, next) {

            a += step;
            next();
        };

        var ticked = Hoek.nextTick(inc);

        ticked(5, function () {

            expect(a).to.equal(6);
            done();
        });

        expect(a).to.equal(0);
        inc(1, function () {

            expect(a).to.equal(1);
        });
    });
});

describe(&#039;once()&#039;, function () {

    it(&#039;allows function to only execute once&#039;, function (done) {

        var gen = 0;
        var add = function (x) {

            gen += x;
        };

        add(5);
        expect(gen).to.equal(5);
        add = Hoek.once(add);
        add(5);
        expect(gen).to.equal(10);
        add(5);
        expect(gen).to.equal(10);
        done();
    });

    it(&#039;double once wraps one time&#039;, function (done) {

        var method = function () { };
        method = Hoek.once(method);
        method.x = 1;
        method = Hoek.once(method);
        expect(method.x).to.equal(1);
        done();
    });
});

describe(&#039;isAbsoltePath()&#039;, function () {

    it(&#039;identifies if path is absolute on Unix without node support&#039;, { parallel: false }, function (done) {

        var orig = Path.isAbsolute;
        Path.isAbsolute = undefined;

        expect(Hoek.isAbsolutePath(&#039;&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;a&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;./a&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;/a&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;/&#039;)).to.equal(true);

        Path.isAbsolute = orig;

        done();
    });

    it(&#039;identifies if path is absolute with fake node support&#039;, { parallel: false }, function (done) {

        var orig = Path.isAbsolute;
        Path.isAbsolute = function (path) {

            return path[0] === &#039;/&#039;;
        };

        expect(Hoek.isAbsolutePath(&#039;&#039;, &#039;linux&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;a&#039;, &#039;linux&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;./a&#039;, &#039;linux&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;/a&#039;, &#039;linux&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;/&#039;, &#039;linux&#039;)).to.equal(true);

        Path.isAbsolute = orig;

        done();
    });

    it(&#039;identifies if path is absolute on Windows without node support&#039;, { parallel: false }, function (done) {

        var orig = Path.isAbsolute;
        Path.isAbsolute = undefined;

        expect(Hoek.isAbsolutePath(&#039;//server/file&#039;, &#039;win32&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;//server/file&#039;, &#039;win32&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;\\\\server\\file&#039;, &#039;win32&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;C:/Users/&#039;, &#039;win32&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;C:\\Users\\&#039;, &#039;win32&#039;)).to.equal(true);
        expect(Hoek.isAbsolutePath(&#039;C:cwd/another&#039;, &#039;win32&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;C:cwd\\another&#039;, &#039;win32&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;directory/directory&#039;, &#039;win32&#039;)).to.equal(false);
        expect(Hoek.isAbsolutePath(&#039;directory\\directory&#039;, &#039;win32&#039;)).to.equal(false);

        Path.isAbsolute = orig;

        done();
    });
});

describe(&#039;isInteger()&#039;, function () {

    it(&#039;validates integers&#039;, function (done) {

        expect(Hoek.isInteger(0)).to.equal(true);
        expect(Hoek.isInteger(1)).to.equal(true);
        expect(Hoek.isInteger(1394035612500)).to.equal(true);
        expect(Hoek.isInteger(&#039;0&#039;)).to.equal(false);
        expect(Hoek.isInteger(1.0)).to.equal(true);
        expect(Hoek.isInteger(1.1)).to.equal(false);
        done();
    });
});

describe(&#039;ignore()&#039;, function () {

    it(&#039;exists&#039;, function (done) {

        expect(Hoek.ignore).to.exist();
        expect(typeof Hoek.ignore).to.equal(&#039;function&#039;);
        done();
    });
});

describe(&#039;inherits()&#039;, function () {

    it(&#039;exists&#039;, function (done) {

        expect(Hoek.inherits).to.exist();
        expect(typeof Hoek.inherits).to.equal(&#039;function&#039;);
        done();
    });
});

describe(&#039;format()&#039;, function () {

    it(&#039;exists&#039;, function (done) {

        expect(Hoek.format).to.exist();
        expect(typeof Hoek.format).to.equal(&#039;function&#039;);
        done();
    });

    it(&#039;is a reference to Util.format&#039;, function (done) {

        expect(Hoek.format(&#039;hello %s&#039;, &#039;world&#039;)).to.equal(&#039;hello world&#039;);
        done();
    });
});

describe(&#039;transform()&#039;, function () {

    var source = {
        address: {
            one: &#039;123 main street&#039;,
            two: &#039;PO Box 1234&#039;
        },
        zip: {
            code: 3321232,
            province: null
        },
        title: &#039;Warehouse&#039;,
        state: &#039;CA&#039;
    };

    var sourcesArray = [{
        address: {
            one: &#039;123 main street&#039;,
            two: &#039;PO Box 1234&#039;
        },
        zip: {
            code: 3321232,
            province: null
        },
        title: &#039;Warehouse&#039;,
        state: &#039;CA&#039;
    }, {
        address: {
            one: &#039;456 market street&#039;,
            two: &#039;PO Box 5678&#039;
        },
        zip: {
            code: 9876,
            province: null
        },
        title: &#039;Garage&#039;,
        state: &#039;NY&#039;
    }];

    it(&#039;transforms an object based on the input object&#039;, function (done) {

        var result = Hoek.transform(source, {
            &#039;person.address.lineOne&#039;: &#039;address.one&#039;,
            &#039;person.address.lineTwo&#039;: &#039;address.two&#039;,
            &#039;title&#039;: &#039;title&#039;,
            &#039;person.address.region&#039;: &#039;state&#039;,
            &#039;person.address.zip&#039;: &#039;zip.code&#039;,
            &#039;person.address.location&#039;: &#039;zip.province&#039;
        });

        expect(result).to.deep.equal({
            person: {
                address: {
                    lineOne: &#039;123 main street&#039;,
                    lineTwo: &#039;PO Box 1234&#039;,
                    region: &#039;CA&#039;,
                    zip: 3321232,
                    location: null
                }
            },
            title: &#039;Warehouse&#039;
        });

        done();
    });

    it(&#039;transforms an array of objects based on the input object&#039;, function (done) {

        var result = Hoek.transform(sourcesArray, {
            &#039;person.address.lineOne&#039;: &#039;address.one&#039;,
            &#039;person.address.lineTwo&#039;: &#039;address.two&#039;,
            &#039;title&#039;: &#039;title&#039;,
            &#039;person.address.region&#039;: &#039;state&#039;,
            &#039;person.address.zip&#039;: &#039;zip.code&#039;,
            &#039;person.address.location&#039;: &#039;zip.province&#039;
        });

        expect(result).to.deep.equal([
            {
                person: {
                    address: {
                        lineOne: &#039;123 main street&#039;,
                        lineTwo: &#039;PO Box 1234&#039;,
                        region: &#039;CA&#039;,
                        zip: 3321232,
                        location: null
                    }
                },
                title: &#039;Warehouse&#039;
            },
            {
                person: {
                    address: {
                        lineOne: &#039;456 market street&#039;,
                        lineTwo: &#039;PO Box 5678&#039;,
                        region: &#039;NY&#039;,
                        zip: 9876,
                        location: null
                    }
                },
                title: &#039;Garage&#039;
            }
        ]);

        done();
    });

    it(&#039;uses the reach options passed into it&#039;, function (done) {

        var schema = {
            &#039;person.address.lineOne&#039;: &#039;address-one&#039;,
            &#039;person.address.lineTwo&#039;: &#039;address-two&#039;,
            &#039;title&#039;: &#039;title&#039;,
            &#039;person.address.region&#039;: &#039;state&#039;,
            &#039;person.prefix&#039;: &#039;person-title&#039;,
            &#039;person.zip&#039;: &#039;zip-code&#039;
        };
        var options = {
            separator: &#039;-&#039;,
            default: &#039;unknown&#039;
        };
        var result = Hoek.transform(source, schema, options);

        expect(result).to.deep.equal({
            person: {
                address: {
                    lineOne: &#039;123 main street&#039;,
                    lineTwo: &#039;PO Box 1234&#039;,
                    region: &#039;CA&#039;
                },
                prefix: &#039;unknown&#039;,
                zip: 3321232
            },
            title: &#039;Warehouse&#039;
        });

        done();
    });

    it(&#039;works to create shallow objects&#039;, function (done) {

        var result = Hoek.transform(source, {
            lineOne: &#039;address.one&#039;,
            lineTwo: &#039;address.two&#039;,
            title: &#039;title&#039;,
            region: &#039;state&#039;,
            province: &#039;zip.province&#039;
        });

        expect(result).to.deep.equal({
            lineOne: &#039;123 main street&#039;,
            lineTwo: &#039;PO Box 1234&#039;,
            title: &#039;Warehouse&#039;,
            region: &#039;CA&#039;,
            province: null
        });

        done();
    });

    it(&#039;only allows strings in the map&#039;, function (done) {

        expect(function () {

            var result = Hoek.transform(source, {
                lineOne: {}
            });
        }).to.throw(&#039;All mappings must be &quot;.&quot; delineated strings&#039;);

        done();
    });

    it(&#039;throws an error on invalid arguments&#039;, function (done) {

        expect(function () {

            var result = Hoek.transform(NaN, {});
        }).to.throw(&#039;Invalid source object: must be null, undefined, an object, or an array&#039;);

        done();
    });

    it(&#039;is safe to pass null&#039;, function (done) {

        var result = Hoek.transform(null, {});
        expect(result).to.deep.equal({});

        done();
    });

    it(&#039;is safe to pass undefined&#039;, function (done) {

        var result = Hoek.transform(undefined, {});
        expect(result).to.deep.equal({});

        done();
    });
});

describe(&#039;uniqueFilename()&#039;, function () {

    it(&#039;generates a random file path&#039;, function (done) {

        var result = Hoek.uniqueFilename(&#039;./test/modules&#039;);

        expect(result).to.exist();
        expect(result).to.be.a.string();
        expect(result).to.contain(&#039;test/modules&#039;);
        done();
    });

    it(&#039;is random enough to use in fast loops&#039;, function (done) {

        var results = [];

        for (var i = 0; i &lt; 10; ++i) {
            results[i] = Hoek.uniqueFilename(&#039;./test/modules&#039;);
        }

        var filter = results.filter(function (item, index, array) {

            return array.indexOf(item) === index;
        });

        expect(filter.length).to.equal(10);
        expect(results.length).to.equal(10);
        done();

    });

    it(&#039;combines the random elements with a supplied character&#039;, function (done) {

        var result = Hoek.uniqueFilename(&#039;./test&#039;, &#039;txt&#039;);

        expect(result).to.contain(&#039;test/&#039;);
        expect(result).to.contain(&#039;.txt&#039;);

        done();
    });

    it(&#039;accepts extensions with a &quot;.&quot; in it&#039;, function (done) {

        var result = Hoek.uniqueFilename(&#039;./test&#039;, &#039;.mp3&#039;);

        expect(result).to.contain(&#039;test/&#039;);
        expect(result).to.contain(&#039;.mp3&#039;);

        done();
    });
});

describe(&#039;stringify()&#039;, function (done) {

    it(&#039;converts object to string&#039;, function (done) {

        var obj = { a: 1 };
        expect(Hoek.stringify(obj)).to.equal(&#039;{&quot;a&quot;:1}&#039;);
        done();
    });

    it(&#039;returns error in result string&#039;, function (done) {

        var obj = { a: 1 };
        obj.b = obj;
        expect(Hoek.stringify(obj)).to.equal(&#039;[Cannot display object: Converting circular structure to JSON]&#039;);
        done();
    });
});

describe(&#039;shallow()&#039;, function (done) {

    it(&#039;shallow copies an object&#039;, function (done) {

        var obj = {
            a: 5,
            b: {
                c: 6
            }
        };

        var shallow = Hoek.shallow(obj);
        expect(shallow).to.not.equal(obj);
        expect(shallow).to.deep.equal(obj);
        expect(shallow.b).to.equal(obj.b);
        done();
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
