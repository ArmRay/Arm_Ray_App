<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/joi/test/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/joi/test/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1692</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">60.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">20.36</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Lab = require(&#039;lab&#039;);
var Code = require(&#039;code&#039;);
var Joi = require(&#039;../lib&#039;);
var Helper = require(&#039;./helper&#039;);


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.describe;
var it = lab.it;
var expect = Code.expect;


describe(&#039;Joi&#039;, function () {

    it(&#039;validates object&#039;, function (done) {

        var schema = Joi.object({
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;),
            c: Joi.string().email().optional()
        }).without(&#039;a&#039;, &#039;none&#039;);

        var obj = {
            a: 1,
            b: &#039;a&#039;,
            c: &#039;joe@example.com&#039;
        };

        schema.validate(obj, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;keeps schema immutable&#039;, function (done) {

        var a = Joi.string();
        var b = a.valid(&#039;b&#039;);

        Helper.validate(a, [
            [&#039;a&#039;, true],
            [&#039;b&#039;, true],
            [5, false]
        ], function () {

            Helper.validate(b, [
                [&#039;a&#039;, false],
                [&#039;b&#039;, true],
                [5, false]
            ], done);
        });

    });

    it(&#039;validates null&#039;, function (done) {

        Joi.string().validate(null, function (err, value) {

            expect(err).to.exist();
            expect(err.annotate()).to.equal(&#039;{\n  \u001b[41m\&quot;value\&quot;\u001b[0m\u001b[31m [1]: -- missing --\u001b[0m\n}\n\u001b[31m\n[1] &quot;value&quot; must be a string\u001b[0m&#039;);
            done();
        });
    });

    it(&#039;validates null schema&#039;, function (done) {

        Helper.validate(null, [
            [&#039;a&#039;, false],
            [null, true]
        ], done);
    });

    it(&#039;validates number literal&#039;, function (done) {

        Helper.validate(5, [
            [6, false],
            [5, true]
        ], done);
    });

    it(&#039;validates string literal&#039;, function (done) {

        Helper.validate(&#039;5&#039;, [
            [&#039;6&#039;, false],
            [&#039;5&#039;, true]
        ], done);
    });

    it(&#039;validates boolean literal&#039;, function (done) {

        Helper.validate(true, [
            [false, false],
            [true, true]
        ], done);
    });

    it(&#039;validates date literal&#039;, function (done) {

        var now = Date.now();
        Helper.validate(new Date(now), [
            [new Date(now), true],
            [now, true],
            [now * 2, false]
        ], done);
    });

    it(&#039;validates complex literal&#039;, function (done) {

        var schema = [&#039;key&#039;, 5, { a: true, b: [/^a/, &#039;boom&#039;] }];
        Helper.validate(schema, [
            [&#039;key&#039;, true],
            [5, true],
            [&#039;other&#039;, false],
            [6, false],
            [{ c: 5 }, false],
            [{}, true],
            [{ b: &#039;abc&#039; }, true],
            [{ a: true, b: &#039;boom&#039; }, true],
            [{ a: 5, b: &#039;a&#039; }, false]
        ], done);
    });

    it(&#039;validates a compiled complex literal&#039;, function (done) {

        var schema = Joi.compile([&#039;key&#039;, 5, { a: true, b: [/^a/, &#039;boom&#039;] }]);
        Helper.validate(schema, [
            [&#039;key&#039;, true],
            [5, true],
            [&#039;other&#039;, false],
            [6, false],
            [{ c: 5 }, false],
            [{}, true],
            [{ b: &#039;abc&#039; }, true],
            [{ a: true, b: &#039;boom&#039; }, true],
            [{ a: 5, b: &#039;a&#039; }, false]
        ], done);
    });

    it(&#039;validates regex directly&#039;, function (done) {

        Joi.compile(/^5$/).validate(&#039;5&#039;, function (err, value) {

            expect(err).to.not.exist();
            Joi.compile(/.{2}/).validate(&#039;6&#039;, function (err2, value2) {

                expect(err2).to.exist();
                done();
            });
        });
    });

    it(&#039;validated with&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string()
        }).with(&#039;txt&#039;, &#039;upc&#039;);

        Joi.validate({ txt: &#039;a&#039; }, schema, { abortEarly: false }, function (err, value) {

            expect(err.message).to.equal(&#039;&quot;txt&quot; missing required peer &quot;upc&quot;&#039;);

            Helper.validate(schema, [
                [{ upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039; }, false],
                [{ txt: &#039;test&#039;, upc: null }, false],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: undefined }, false],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039; }, true]
            ], done);
        });
    });

    it(&#039;validated without&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string()
        }).without(&#039;txt&#039;, &#039;upc&#039;);

        Joi.validate({ txt: &#039;a&#039;, upc: &#039;b&#039; }, schema, { abortEarly: false }, function (err, value) {

            expect(err.message).to.equal(&#039;&quot;txt&quot; conflict with forbidden peer &quot;upc&quot;&#039;);

            Helper.validate(schema, [
                [{ upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: null }, false],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: undefined }, true],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039; }, false]
            ], done);
        });
    });

    it(&#039;validates xor&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string()
        }).xor(&#039;txt&#039;, &#039;upc&#039;);

        Joi.validate({}, schema, { abortEarly: false }, function (err, value) {

            expect(err.message).to.equal(&#039;&quot;value&quot; must contain at least one of [txt, upc]&#039;);

            Helper.validate(schema, [
                [{ upc: null }, false],
                [{ upc: &#039;test&#039; }, true],
                [{ txt: null }, false],
                [{ txt: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: null }, false],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;&#039;, upc: &#039;test&#039; }, false],
                [{ txt: null, upc: &#039;test&#039; }, false],
                [{ txt: undefined, upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: undefined }, true],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: null }, false],
                [{ txt: &#039;&#039;, upc: undefined }, false],
                [{ txt: &#039;&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039; }, false]
            ], done);
        });
    });

    it(&#039;validates multiple peers xor&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string(),
            code: Joi.string()
        }).xor(&#039;txt&#039;, &#039;upc&#039;, &#039;code&#039;);

        Helper.validate(schema, [
            [{ upc: &#039;test&#039; }, true],
            [{ txt: &#039;test&#039; }, true],
            [{}, false]
        ], done);
    });

    it(&#039;validates xor with number types&#039;, function (done) {

        var schema = Joi.object({
            code: Joi.number(),
            upc: Joi.number()
        }).xor(&#039;code&#039;, &#039;upc&#039;);

        Helper.validate(schema, [
            [{ upc: 123 }, true],
            [{ code: 456 }, true],
            [{ code: 456, upc: 123 }, false],
            [{}, false]
        ], done);
    });

    it(&#039;validates xor when empty value of peer allowed&#039;, function (done) {

        var schema = Joi.object({
            code: Joi.string(),
            upc: Joi.string().allow(&#039;&#039;)
        }).xor(&#039;code&#039;, &#039;upc&#039;);

        Helper.validate(schema, [
            [{ upc: &#039;&#039; }, true],
            [{ upc: &#039;123&#039; }, true],
            [{ code: &#039;456&#039; }, true],
            [{ code: &#039;456&#039;, upc: &#039;&#039; }, false],
            [{}, false]
        ], done);
    });

    it(&#039;validates or&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string().allow(null, &#039;&#039;),
            code: Joi.number()
        }).or(&#039;txt&#039;, &#039;upc&#039;, &#039;code&#039;);

        Joi.validate({}, schema, { abortEarly: false }, function (err, value) {

            expect(err.message).to.equal(&#039;&quot;value&quot; must contain at least one of [txt, upc, code]&#039;);

            Helper.validate(schema, [
                [{ upc: null }, true],
                [{ upc: &#039;test&#039; }, true],
                [{ txt: null }, false],
                [{ txt: &#039;test&#039; }, true],
                [{ code: null }, false],
                [{ code: 123 }, true],
                [{ txt: &#039;test&#039;, upc: null }, true],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, true],
                [{ txt: &#039;&#039;, upc: &#039;test&#039; }, false],
                [{ txt: null, upc: &#039;test&#039; }, false],
                [{ txt: undefined, upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: undefined }, true],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, true],
                [{ txt: &#039;test&#039;, upc: null }, true],
                [{ txt: &#039;&#039;, upc: undefined }, false],
                [{ txt: &#039;&#039;, upc: undefined, code: 999 }, false],
                [{ txt: &#039;&#039;, upc: undefined, code: undefined }, false],
                [{ txt: &#039;&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039;, code: 322 }, true]
            ], done);
        });
    });

    it(&#039;validates and&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string().allow(null, &#039;&#039;),
            code: Joi.number()
        }).and(&#039;txt&#039;, &#039;upc&#039;, &#039;code&#039;);

        Joi.validate({ txt: &#039;x&#039; }, schema, { abortEarly: false }, function (err, value) {

            expect(err.message).to.equal(&#039;&quot;value&quot; contains [txt] without its required peers [upc, code]&#039;);

            Helper.validate(schema, [
                [{}, true],
                [{ upc: null }, false],
                [{ upc: &#039;test&#039; }, false],
                [{ txt: null }, false],
                [{ txt: &#039;test&#039; }, false],
                [{ code: null }, false],
                [{ code: 123 }, false],
                [{ txt: &#039;test&#039;, upc: null }, false],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;&#039;, upc: &#039;test&#039; }, false],
                [{ txt: null, upc: &#039;test&#039; }, false],
                [{ txt: undefined, upc: &#039;test&#039; }, false],
                [{ txt: &#039;test&#039;, upc: undefined }, false],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: null }, false],
                [{ txt: &#039;&#039;, upc: undefined }, false],
                [{ txt: &#039;&#039;, upc: undefined, code: 999 }, false],
                [{ txt: &#039;&#039;, upc: undefined, code: undefined }, false],
                [{ txt: &#039;&#039;, upc: &#039;&#039; }, false],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039; }, false],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039;, code: 322 }, true],
                [{ txt: &#039;test&#039;, upc: null, code: 322 }, true]
            ], done);
        });
    });

    it(&#039;validates nand()&#039;, function (done) {

        var schema = Joi.object({
            txt: Joi.string(),
            upc: Joi.string().allow(null, &#039;&#039;),
            code: Joi.number()
        }).nand(&#039;txt&#039;, &#039;upc&#039;, &#039;code&#039;);

        Joi.validate({ txt: &#039;x&#039;, upc: &#039;y&#039;, code: 123 }, schema, { abortEarly: false }, function (err, value) {

            expect(err.message).to.equal(&#039;&quot;txt&quot; must not exist simultaneously with [upc, code]&#039;);

            Helper.validate(schema, [
                [{}, true],
                [{ upc: null }, true],
                [{ upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039; }, true],
                [{ code: 123 }, true],
                [{ txt: &#039;test&#039;, upc: null }, true],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, true],
                [{ txt: undefined, upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: undefined }, true],
                [{ txt: &#039;test&#039;, upc: &#039;&#039; }, true],
                [{ txt: &#039;test&#039;, upc: null }, true],
                [{ txt: &#039;test&#039;, upc: undefined, code: 999 }, true],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039; }, true],
                [{ txt: &#039;test&#039;, upc: &#039;test&#039;, code: 322 }, false],
                [{ txt: &#039;test&#039;, upc: null, code: 322 }, false]
            ], done);
        });
    });

    it(&#039;validates an array of valid types&#039;, function (done) {

        var schema = Joi.object({
            auth: [
                Joi.object({
                    mode: Joi.string().valid(&#039;required&#039;, &#039;optional&#039;, &#039;try&#039;).allow(null)
                }).allow(null),
                Joi.string(),
                Joi.boolean()
            ]
        });

        schema.validate({ auth: { mode: &#039;none&#039; } }, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.equal(&#039;child &quot;auth&quot; fails because [child &quot;mode&quot; fails because [&quot;mode&quot; must be one of [required, optional, try, null]], &quot;auth&quot; must be a string, &quot;auth&quot; must be a boolean]&#039;);

            Helper.validate(schema, [
                [{ auth: { mode: &#039;try&#039; } }, true],
                [{ something: undefined }, false],
                [{ auth: { something: undefined } }, false],
                [{ auth: null }, true],
                [{ auth: undefined }, true],
                [{}, true],
                [{ auth: true }, true],
                [{ auth: 123 }, false]
            ], done);
        });
    });

    it(&#039;validates alternatives&#039;, function (done) {

        var schema = Joi.object({
            auth: Joi.alternatives(
                Joi.object({
                    mode: Joi.string().valid(&#039;required&#039;, &#039;optional&#039;, &#039;try&#039;).allow(null)
                }).allow(null),
                Joi.string(),
                Joi.boolean()
            )
        });

        schema.validate({ auth: { mode: &#039;none&#039; } }, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.equal(&#039;child &quot;auth&quot; fails because [child &quot;mode&quot; fails because [&quot;mode&quot; must be one of [required, optional, try, null]], &quot;auth&quot; must be a string, &quot;auth&quot; must be a boolean]&#039;);

            Helper.validate(schema, [
                [{ auth: { mode: &#039;try&#039; } }, true],
                [{ something: undefined }, false],
                [{ auth: { something: undefined } }, false],
                [{ auth: null }, true],
                [{ auth: undefined }, true],
                [{}, true],
                [{ auth: true }, true],
                [{ auth: 123 }, false]
            ], done);
        });
    });

    it(&#039;validates required alternatives&#039;, function (done) {

        var schema = {
            a: Joi.alternatives(
                Joi.string().required(),
                Joi.boolean().required()
            )
        };

        Helper.validate(schema, [
            [{ a: null }, false],
            [{ a: undefined }, true],
            [{}, true],
            [{ a: true }, true],
            [{ a: &#039;true&#039; }, true],
            [{ a: 123 }, false],
            [{ a: { c: 1 } }, false],
            [{ b: undefined }, false]
        ], done);
    });

    it(&#039;validates required [] alternatives&#039;, function (done) {

        var schema = {
            a: [
                Joi.string().required(),
                Joi.boolean().required()
            ]
        };

        Helper.validate(schema, [
            [{ a: null }, false],
            [{ a: undefined }, true],
            [{}, true],
            [{ a: true }, true],
            [{ a: &#039;true&#039; }, true],
            [{ a: 123 }, false],
            [{ a: { c: 1 } }, false],
            [{ b: undefined }, false]
        ], done);
    });

    it(&#039;validates an array of string with valid&#039;, function (done) {

        var schema = {
            brand: Joi.array().items(Joi.string().valid(&#039;amex&#039;, &#039;visa&#039;))
        };

        Helper.validate(schema, [
            [{ brand: [&#039;amex&#039;] }, true],
            [{ brand: [&#039;visa&#039;, &#039;mc&#039;] }, false]
        ], done);
    });

    it(&#039;validates pre and post convert value&#039;, function (done) {

        var schema = Joi.number().valid(5);

        Helper.validate(schema, [
            [5, true],
            [&#039;5&#039;, true]
        ], done);
    });

    it(&#039;does not change object when validation fails&#039;, function (done) {

        var schema = Joi.object({
            a: Joi.number().valid(2)
        });

        var obj = {
            a: &#039;5&#039;
        };

        schema.validate(obj, function (err, value) {

            expect(err).to.exist();
            expect(value.a).to.equal(&#039;5&#039;);
            done();
        });
    });

    it(&#039;does not set optional keys when missing&#039;, function (done) {

        var schema = Joi.object({
            a: Joi.number()
        });

        var obj = {};

        schema.validate(obj, function (err, value) {

            expect(err).to.not.exist();
            expect(value.hasOwnProperty(&#039;a&#039;)).to.equal(false);
            done();
        });
    });

    it(&#039;invalidates pre and post convert value&#039;, function (done) {

        var schema = Joi.number().invalid(5);

        Helper.validate(schema, [
            [5, false],
            [&#039;5&#039;, false]
        ], done);
    });

    it(&#039;invalidates missing peers&#039;, function (done) {

        var schema = Joi.object({
            username: Joi.string(),
            password: Joi.string()
        }).with(&#039;username&#039;, &#039;password&#039;).without(&#039;password&#039;, &#039;access_token&#039;);

        schema.validate({ username: &#039;bob&#039; }, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;validates config where the root item is a joi type&#039;, function (done) {

        Joi.boolean().allow(null).validate(true, function (err, value) {

            expect(err).to.be.null();
            Joi.object().validate({ auth: { mode: &#039;try&#039; } }, function (err2, value2) {

                expect(err2).to.be.null();

                Joi.object().validate(true, function (err3, value3) {

                    expect(err3.message).to.contain(&#039;&quot;value&quot; must be an object&#039;);

                    Joi.string().validate(true, function (err4, value4) {

                        expect(err4.message).to.contain(&#039;&quot;value&quot; must be a string&#039;);

                        Joi.string().email().validate(&#039;test@test.com&#039;, function (err5, value5) {

                            expect(err5).to.be.null();
                            Joi.object({ param: Joi.string().required() }).validate({ param: &#039;item&#039; }, function (err6, value6) {

                                expect(err6).to.be.null();
                                done();
                            });
                        });
                    });
                });
            });
        });
    });

    it(&#039;converts string to number&#039;, function (done) {

        var schema = Joi.object({
            a: Joi.number()
        });

        var input = { a: &#039;5&#039; };
        schema.validate(input, function (err, value) {

            expect(err).to.be.null();
            expect(value.a).to.equal(5);
            expect(input.a).to.equal(&#039;5&#039;);
            done();
        });
    });

    it(&#039;allows unknown keys in objects if no schema was given&#039;, function (done) {

        Joi.object().validate({ foo: &#039;bar&#039; }, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;fails on unknown keys in objects if a schema was given&#039;, function (done) {

        Joi.object({}).validate({ foo: &#039;bar&#039; }, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.equal(&#039;&quot;foo&quot; is not allowed&#039;);

            Joi.compile({}).validate({ foo: &#039;bar&#039; }, function (err2, value2) {

                expect(err2).to.exist();
                expect(err2.message).to.equal(&#039;&quot;foo&quot; is not allowed&#039;);

                Joi.compile({ other: Joi.number() }).validate({ foo: &#039;bar&#039; }, function (err3, value3) {

                    expect(err3).to.exist();
                    expect(err3.message).to.equal(&#039;&quot;foo&quot; is not allowed&#039;);

                    done();
                });
            });
        });
    });

    it(&#039;validates an unknown option&#039;, function (done) {

        var config = {
            auth: Joi.object({
                mode: Joi.string().valid(&#039;required&#039;, &#039;optional&#039;, &#039;try&#039;).allow(null)
            }).allow(null)
        };

        Joi.compile(config).validate({ auth: { unknown: true } }, function (err, value) {

            expect(err).to.not.be.null();
            expect(err.message).to.contain(&#039;&quot;unknown&quot; is not allowed&#039;);

            Joi.compile(config).validate({ something: false }, function (err2, value2) {

                expect(err2).to.not.be.null();
                expect(err2.message).to.contain(&#039;&quot;something&quot; is not allowed&#039;);

                done();
            });
        });
    });

    it(&#039;validates required key with multiple options&#039;, function (done) {

        var config = {
            module: Joi.alternatives([
                Joi.object({
                    compile: Joi.func().required(),
                    execute: Joi.func()
                }),
                Joi.string()
            ]).required()
        };

        Joi.compile(config).validate({}, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.contain(&#039;&quot;module&quot; is required&#039;);

            Joi.compile(config).validate({ module: &#039;test&#039; }, function (err2, value2) {

                expect(err2).to.be.null();

                Joi.compile(config).validate({ module: {} }, function (err3, value3) {

                    expect(err3).to.not.be.null();
                    expect(err3.message).to.contain(&#039;&quot;compile&quot; is required&#039;);
                    expect(err3.message).to.contain(&#039;&quot;module&quot; must be a string&#039;);

                    Joi.compile(config).validate({ module: { compile: function () { } } }, function (err4, value4) {

                        expect(err4).to.be.null();
                        done();
                    });
                });
            });
        });
    });

    it(&#039;validates key with required alternatives&#039;, function (done) {

        var config = {
            module: Joi.alt().try(
                Joi.object({
                    compile: Joi.func().required(),
                    execute: Joi.func()
                }).required(),
                Joi.string().required()
            )
        };

        Joi.compile(config).validate({}, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;validates required key with alternatives&#039;, function (done) {

        var config = {
            module: Joi.alt().try(
                Joi.object({
                    compile: Joi.func().required(),
                    execute: Joi.func()
                }),
                Joi.string()
            ).required()
        };

        Joi.compile(config).validate({}, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.contain(&#039;&quot;module&quot; is required&#039;);
            done();
        });
    });

    it(&#039;does not require optional numbers&#039;, function (done) {

        var config = {
            position: Joi.number(),
            suggestion: Joi.string()
        };

        Joi.compile(config).validate({ suggestion: &#039;something&#039; }, function (err, value) {

            expect(err).to.be.null();

            Joi.compile(config).validate({ position: 1 }, function (err2, value2) {

                expect(err2).to.be.null();
                done();
            });
        });
    });

    it(&#039;does not require optional objects&#039;, function (done) {

        var config = {
            position: Joi.number(),
            suggestion: Joi.object()
        };

        Joi.compile(config).validate({ suggestion: {} }, function (err, value) {

            expect(err).to.be.null();

            Joi.compile(config).validate({ position: 1 }, function (err2, value2) {

                expect(err2).to.be.null();
                done();
            });
        });
    });

    it(&#039;validates object successfully when config has an array of types&#039;, function (done) {

        var schema = {
            f: [Joi.number(), Joi.boolean()],
            g: [Joi.string(), Joi.object()]
        };

        var obj = {
            f: true,
            g: &#039;test&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;validates object successfully when config allows for optional key and key is missing&#039;, function (done) {

        var schema = {
            h: Joi.number(),
            i: Joi.string(),
            j: Joi.object()
        };

        var obj = {
            h: 12,
            i: &#039;test&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;fails validation&#039;, function (done) {

        var schema = {
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;),
            c: Joi.string().email().optional()
        };

        var obj = {
            a: 10,
            b: &#039;a&#039;,
            c: &#039;joe@example.com&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when the wrong types are supplied&#039;, function (done) {

        var schema = {
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;),
            c: Joi.string().email().optional()
        };

        var obj = {
            a: &#039;a&#039;,
            b: &#039;a&#039;,
            c: &#039;joe@example.com&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when missing a required parameter&#039;, function (done) {

        var obj = {
            c: 10
        };

        Joi.compile({ a: Joi.string().required() }).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when missing a required parameter within an object config&#039;, function (done) {

        var obj = {
            a: {}
        };

        Joi.compile({ a: Joi.object({ b: Joi.string().required() }) }).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when parameter is required to be an object but is given as string&#039;, function (done) {

        var obj = {
            a: &#039;a string&#039;
        };

        Joi.compile({ a: Joi.object({ b: Joi.string().required() }) }).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;validates when parameter is required to be an object and is given correctly as a json string&#039;, function (done) {

        var schema = {
            a: Joi.object({
                b: Joi.string().required()
            })
        };

        var input = {
            a: &#039;{&quot;b&quot;:&quot;string&quot;}&#039;
        };

        Joi.validate(input, schema, function (err, value) {

            expect(err).to.not.exist();
            expect(input.a).to.equal(&#039;{&quot;b&quot;:&quot;string&quot;}&#039;);
            expect(value.a.b).to.equal(&#039;string&#039;);
            done();
        });
    });

    it(&#039;fails validation when parameter is required to be an object but is given as a json string that is incorrect (number instead of string)&#039;, function (done) {

        var obj = {
            a: &#039;{&quot;b&quot;:2}&#039;
        };

        Joi.object({ a: Joi.object({ b: Joi.string().required() }) }).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when parameter is required to be an Array but is given as string&#039;, function (done) {

        var obj = {
            a: &#039;an array&#039;
        };

        Joi.object({ a: Joi.array() }).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;validates when parameter is required to be an Array and is given correctly as a json string&#039;, function (done) {

        var obj = {
            a: &#039;[1,2]&#039;
        };

        Joi.object({ a: Joi.array() }).validate(obj, function (err, value) {

            expect(err).to.be.null();
            done();
        });
    });

    it(&#039;fails validation when parameter is required to be an Array but is given as a json that is incorrect (object instead of array)&#039;, function (done) {

        var obj = {
            a: &#039;{&quot;b&quot;:2}&#039;
        };

        Joi.object({ a: Joi.object({ b: Joi.string().required() }) }).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when config is an array and fails&#039;, function (done) {

        var schema = {
            d: [Joi.string(), Joi.boolean()],
            e: [Joi.number(), Joi.object()]
        };

        var obj = {
            d: 10,
            e: &#039;a&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation when config is an array and fails with extra keys&#039;, function (done) {

        var schema = {
            d: [Joi.string(), Joi.boolean()],
            e: [Joi.number(), Joi.object()]
        };

        var obj = {
            a: 10,
            b: &#039;a&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;fails validation with extra keys&#039;, function (done) {

        var schema = {
            a: Joi.number()
        };

        var obj = {
            a: 1,
            b: &#039;a&#039;
        };

        Joi.compile(schema).validate(obj, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;validates missing optional key with string condition&#039;, function (done) {

        var schema = {
            key: Joi.string().alphanum(false).min(8)
        };

        Joi.compile(schema).validate({}, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;validates with extra keys and remove them when stripUnknown is set&#039;, function (done) {

        var schema = {
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;),
            c: Joi.string().email().optional()
        };

        var obj = {
            a: 1,
            b: &#039;a&#039;,
            d: &#039;c&#039;
        };

        Joi.validate(obj, schema, { stripUnknown: true, allowUnknown: true }, function (err, value) {

            expect(err).to.be.null();
            expect(value).to.deep.equal({ a: 1, b: &#039;a&#039; });
            done();
        });
    });

    it(&#039;validates dependencies when stripUnknown is set&#039;, function (done) {

        var schema = Joi.object({
            a: Joi.number(),
            b: Joi.string()
        }).and(&#039;a&#039;, &#039;b&#039;);

        var obj = {
            a: 1,
            foo: &#039;bar&#039;
        };

        Joi.validate(obj, schema, { stripUnknown: true }, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.equal(&#039;&quot;value&quot; contains [a] without its required peers [b]&#039;);
            done();
        });
    });

    it(&#039;fails to validate with incorrect property when asked to strip unkown keys without aborting early&#039;, function (done) {

        var schema = {
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;),
            c: Joi.string().email().optional()
        };

        var obj = {
            a: 1,
            b: &#039;f&#039;,
            d: &#039;c&#039;
        };

        Joi.validate(obj, schema, { stripUnknown: true, abortEarly: false }, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;should pass validation with extra keys when allowUnknown is set&#039;, function (done) {

        var schema = {
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;),
            c: Joi.string().email().optional()
        };

        var obj = {
            a: 1,
            b: &#039;a&#039;,
            d: &#039;c&#039;
        };

        Joi.validate(obj, schema, { allowUnknown: true }, function (err, value) {

            expect(err).to.be.null();
            expect(value).to.deep.equal({ a: 1, b: &#039;a&#039;, d: &#039;c&#039; });
            done();
        });
    });

    it(&#039;should pass validation with extra keys set&#039;, function (done) {

        var localConfig = Joi.object({
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;)
        }).options({ allowUnknown: true });

        var obj = {
            a: 1,
            b: &#039;a&#039;,
            d: &#039;c&#039;
        };

        localConfig.validate(obj, function (err, value) {

            expect(err).to.be.null();
            expect(value).to.deep.equal({ a: 1, b: &#039;a&#039;, d: &#039;c&#039; });

            localConfig.validate(value, function (err2, value2) {

                expect(err2).to.be.null();
                expect(value2).to.deep.equal({ a: 1, b: &#039;a&#039;, d: &#039;c&#039; });
                done();
            });
        });
    });


    it(&#039;should pass validation with extra keys and remove them when skipExtraKeys is set locally&#039;, function (done) {

        var localConfig = Joi.object({
            a: Joi.number().min(0).max(3),
            b: Joi.string().valid(&#039;a&#039;, &#039;b&#039;, &#039;c&#039;)
        }).options({ stripUnknown: true, allowUnknown: true });

        var obj = {
            a: 1,
            b: &#039;a&#039;,
            d: &#039;c&#039;
        };

        localConfig.validate(obj, function (err, value) {

            expect(err).to.be.null();
            expect(value).to.deep.equal({ a: 1, b: &#039;a&#039; });

            localConfig.validate(value, function (err2, value2) {

                expect(err2).to.be.null();
                expect(value2).to.deep.equal({ a: 1, b: &#039;a&#039; });
                done();
            });
        });
    });

    it(&#039;should work when the skipFunctions setting is enabled&#039;, function (done) {

        var schema = Joi.object({ username: Joi.string() }).options({ skipFunctions: true });
        var input = { username: &#039;test&#039;, func: function () { } };
        Joi.validate(input, schema, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;should work when the skipFunctions setting is disabled&#039;, function (done) {

        var schema = { username: Joi.string() };
        var input = { username: &#039;test&#039;, func: function () { } };

        Joi.validate(input, schema, { skipFunctions: false }, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.contain(&#039;&quot;func&quot; is not allowed&#039;);
            done();
        });
    });

    it(&#039;should not convert values when convert is false&#039;, function (done) {

        var schema = {
            arr: Joi.array().items(Joi.string())
        };

        var input = { arr: &#039;foo&#039; };
        Joi.validate(input, schema, { convert: false }, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;full errors when abortEarly is false&#039;, function (done) {

        var schema = {
            a: Joi.string(),
            b: Joi.string()
        };

        var input = { a: 1, b: 2 };

        Joi.validate(input, schema, function (errOne, valueOne) {

            Joi.validate(input, schema, { abortEarly: false }, function (errFull, valueFull) {

                expect(errOne).to.exist();
                expect(errFull).to.exist();
                expect(errFull.details.length).to.be.greaterThan(errOne.details.length);
                done();
            });
        });
    });

    it(&#039;errors multiple times when abortEarly is false in a complex object&#039;, function (done) {

        var schema = Joi.object({
            test: Joi.array().items(Joi.object().keys({
                foo: Joi.string().required().max(3),
                bar: Joi.string().max(5)
            })),
            test2: Joi.object({
                test3: Joi.array().items(Joi.object().keys({
                    foo: Joi.string().required().max(3),
                    bar: Joi.string().max(5),
                    baz: Joi.object({
                        test4: Joi.array().items(Joi.object().keys({
                            foo: Joi.string().required().max(3),
                            bar: Joi.string().max(5)
                        }))
                    })
                }))
            })
        });

        var input = {
            test: [{
                foo: &#039;test1&#039;,
                bar: &#039;testfailed&#039;
            }],
            test2: {
                test3: [{
                    foo: &#039;123&#039;
                }, {
                    foo: &#039;test1&#039;,
                    bar: &#039;testfailed&#039;
                }, {
                    foo: &#039;123&#039;,
                    baz: {
                        test4: [{
                            foo: &#039;test1&#039;,
                            baz: &#039;123&#039;
                        }]
                    }
                }]
            }
        };

        Joi.validate(input, schema, { abortEarly: false }, function (err, value) {

            expect(err).to.exist();
            expect(err.details).to.have.length(6);
            expect(err.details).to.deep.equal([{
                message: &#039;&quot;foo&quot; length must be less than or equal to 3 characters long&#039;,
                path: &#039;test.0.foo&#039;,
                type: &#039;string.max&#039;,
                context: { limit: 3, value: &#039;test1&#039;, key: &#039;foo&#039;, encoding: undefined }
            }, {
                message: &#039;&quot;bar&quot; length must be less than or equal to 5 characters long&#039;,
                path: &#039;test.0.bar&#039;,
                type: &#039;string.max&#039;,
                context: { limit: 5, value: &#039;testfailed&#039;, key: &#039;bar&#039;, encoding: undefined }
            }, {
                message: &#039;&quot;foo&quot; length must be less than or equal to 3 characters long&#039;,
                path: &#039;test2.test3.1.foo&#039;,
                type: &#039;string.max&#039;,
                context: { limit: 3, value: &#039;test1&#039;, key: &#039;foo&#039;, encoding: undefined }
            }, {
                message: &#039;&quot;bar&quot; length must be less than or equal to 5 characters long&#039;,
                path: &#039;test2.test3.1.bar&#039;,
                type: &#039;string.max&#039;,
                context: { limit: 5, value: &#039;testfailed&#039;, key: &#039;bar&#039;, encoding: undefined }
            }, {
                message: &#039;&quot;foo&quot; length must be less than or equal to 3 characters long&#039;,
                path: &#039;test2.test3.2.baz.test4.0.foo&#039;,
                type: &#039;string.max&#039;,
                context: { limit: 3, value: &#039;test1&#039;, key: &#039;foo&#039;, encoding: undefined }
            }, {
                message: &#039;&quot;baz&quot; is not allowed&#039;,
                path: &#039;test2.test3.2.baz.test4.0.baz&#039;,
                type: &#039;object.allowUnknown&#039;,
                context: { key: &#039;baz&#039; }
            }]);
            done();
        });
    });

    it(&#039;validates using the root any object&#039;, function (done) {

        var any = Joi;
        any.validate(&#039;abc&#039;, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;validates using the root any object (no callback)&#039;, function (done) {

        var any = Joi;
        var result = any.validate(&#039;abc&#039;);
        expect(result.error).to.not.exist();
        expect(result.value).to.equal(&#039;abc&#039;);
        done();
    });

    it(&#039;accepts no options&#039;, function (done) {

        Joi.validate(&#039;test&#039;, Joi.string(), function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;accepts no options (no callback)&#039;, function (done) {

        var result = Joi.validate(&#039;test&#039;, Joi.string());
        expect(result.error).to.not.exist();
        expect(result.value).to.equal(&#039;test&#039;);
        done();
    });

    it(&#039;accepts options&#039;, function (done) {

        Joi.validate(&#039;5&#039;, Joi.number(), { convert: false }, function (err, value) {

            expect(err).to.exist();
            done();
        });
    });

    it(&#039;accepts options (no callback)&#039;, function (done) {

        var result = Joi.validate(&#039;5&#039;, Joi.number(), { convert: false });
        expect(result.error).to.exist();
        done();
    });

    it(&#039;accepts null options&#039;, function (done) {

        Joi.validate(&#039;test&#039;, Joi.string(), null, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    it(&#039;accepts undefined options&#039;, function (done) {

        Joi.validate(&#039;test&#039;, Joi.string(), undefined, function (err, value) {

            expect(err).to.not.exist();
            done();
        });
    });

    describe(&#039;#describe&#039;, function () {

        var defaultFn = function () {

            return &#039;test&#039;;
        };
        defaultFn.description = &#039;testing&#039;;

        var defaultDescribedFn = function () {

            return &#039;test&#039;;
        };

        var defaultRef = Joi.ref(&#039;xor&#039;);

        var schema = Joi.object({
            sub: {
                email: Joi.string().email(),
                date: Joi.date(),
                child: Joi.object({
                    alphanum: Joi.string().alphanum()
                })
            },
            min: [Joi.number(), Joi.string().min(3)],
            max: Joi.string().max(3),
            required: Joi.string().required(),
            xor: Joi.string(),
            renamed: Joi.string().valid(&#039;456&#039;),
            notEmpty: Joi.string().required().description(&#039;a&#039;).notes(&#039;b&#039;).tags(&#039;c&#039;),
            empty: Joi.string().empty(&#039;&#039;).strip(),
            defaultRef: Joi.string().default(defaultRef, &#039;not here&#039;),
            defaultFn: Joi.string().default(defaultFn, &#039;not here&#039;),
            defaultDescribedFn: Joi.string().default(defaultDescribedFn, &#039;described test&#039;)
        }).rename(&#039;renamed&#039;, &#039;required&#039;).without(&#039;required&#039;, &#039;xor&#039;).without(&#039;xor&#039;, &#039;required&#039;);

        var result = {
            type: &#039;object&#039;,
            children: {
                sub: {
                    type: &#039;object&#039;,
                    children: {
                        email: {
                            type: &#039;string&#039;,
                            invalids: [&#039;&#039;],
                            rules: [{ name: &#039;email&#039; }]
                        },
                        date: {
                            type: &#039;date&#039;
                        },
                        child: {
                            type: &#039;object&#039;,
                            children: {
                                alphanum: {
                                    type: &#039;string&#039;,
                                    invalids: [&#039;&#039;],
                                    rules: [{ name: &#039;alphanum&#039; }]
                                }
                            }
                        }
                    }
                },
                min: {
                    type: &#039;alternatives&#039;,
                    alternatives: [
                        {
                            type: &#039;number&#039;,
                            invalids: [Infinity, -Infinity]
                        },
                        {
                            type: &#039;string&#039;,
                            invalids: [&#039;&#039;],
                            rules: [{ name: &#039;min&#039;, arg: 3 }]
                        }
                    ]
                },
                max: {
                    type: &#039;string&#039;,
                    invalids: [&#039;&#039;],
                    rules: [{ name: &#039;max&#039;, arg: 3 }]
                },
                required: {
                    type: &#039;string&#039;,
                    flags: {
                        presence: &#039;required&#039;
                    },
                    invalids: [&#039;&#039;]
                },
                xor: {
                    type: &#039;string&#039;,
                    invalids: [&#039;&#039;]
                },
                renamed: {
                    type: &#039;string&#039;,
                    flags: {
                        allowOnly: true
                    },
                    valids: [&#039;456&#039;],
                    invalids: [&#039;&#039;]
                },
                notEmpty: {
                    type: &#039;string&#039;,
                    flags: {
                        presence: &#039;required&#039;
                    },
                    description: &#039;a&#039;,
                    notes: [&#039;b&#039;],
                    tags: [&#039;c&#039;],
                    invalids: [&#039;&#039;]
                },
                empty: {
                    type: &#039;string&#039;,
                    flags: {
                        empty: {
                            type: &#039;string&#039;,
                            flags: {
                                allowOnly: true
                            },
                            valids: [&#039;&#039;]
                        },
                        strip: true
                    },
                    invalids: [&#039;&#039;]
                },
                defaultRef: {
                    type: &#039;string&#039;,
                    flags: {
                        default: defaultRef
                    },
                    invalids: [&#039;&#039;]
                },
                defaultFn: {
                    type: &#039;string&#039;,
                    flags: {
                        default: defaultFn
                    },
                    invalids: [&#039;&#039;]
                },
                defaultDescribedFn: {
                    type: &#039;string&#039;,
                    flags: {
                        default: defaultDescribedFn
                    },
                    invalids: [&#039;&#039;]
                }
            },
            dependencies: [
                {
                    type: &#039;without&#039;,
                    key: &#039;required&#039;,
                    peers: [&#039;xor&#039;]
                },
                {
                    type: &#039;without&#039;,
                    key: &#039;xor&#039;,
                    peers: [&#039;required&#039;]
                }
            ]
        };

        it(&#039;describes schema (direct)&#039;, function (done) {

            var description = schema.describe();
            expect(description).to.deep.equal(result);
            expect(description.children.defaultRef.flags.default.description).to.not.exist();
            expect(description.children.defaultFn.flags.default.description).to.equal(&#039;testing&#039;);
            expect(description.children.defaultDescribedFn.flags.default.description).to.equal(&#039;described test&#039;);
            done();
        });

        it(&#039;describes schema (root)&#039;, function (done) {

            var description = Joi.describe(schema);
            expect(description).to.deep.equal(result);
            done();
        });

        it(&#039;describes schema (any)&#039;, function (done) {

            var any = Joi;
            var description = any.describe();
            expect(description).to.deep.equal({
                type: &#039;any&#039;
            });
            done();
        });

        it(&#039;describes schema without invalids&#039;, function (done) {

            var description = Joi.allow(null).describe();
            expect(description.invalids).to.not.exist();
            done();
        });
    });

    describe(&#039;#assert&#039;, function () {

        it(&#039;does not have a return value&#039;, function (done) {

            var result;
            expect(function () {

                result = Joi.assert(&#039;4&#039;, Joi.number());
            }).to.not.throw();
            expect(result).to.not.exist();
            done();
        });
    });

    describe(&#039;#attempt&#039;, function () {

        it(&#039;throws on invalid value&#039;, function (done) {

            expect(function () {

                Joi.attempt(&#039;x&#039;, Joi.number());
            }).to.throw(&#039;&quot;x&quot;\n\u001b[31m\n[1] &quot;value&quot; must be a number\u001b[0m&#039;);
            done();
        });

        it(&#039;does not throw on valid value&#039;, function (done) {

            expect(function () {

                Joi.attempt(&#039;4&#039;, Joi.number());
            }).to.not.throw();
            done();
        });

        it(&#039;returns validated structure&#039;, function (done) {

            var valid;
            expect(function () {

                valid = Joi.attempt(&#039;4&#039;, Joi.number());
            }).to.not.throw();
            expect(valid).to.equal(4);
            done();
        });

        it(&#039;throws on invalid value with message&#039;, function (done) {

            expect(function () {

                Joi.attempt(&#039;x&#039;, Joi.number(), &#039;the reason is&#039;);
            }).to.throw(&#039;the reason is &quot;x&quot;\n\u001b[31m\n[1] &quot;value&quot; must be a number\u001b[0m&#039;);
            done();
        });

        it(&#039;throws on invalid value with message as error&#039;, function (done) {

            expect(function () {

                Joi.attempt(&#039;x&#039;, Joi.number(), new Error(&#039;invalid value&#039;));
            }).to.throw(&#039;invalid value&#039;);
            done();
        });
    });

    describe(&#039;#compile&#039;, function () {

        it(&#039;throws an error on invalid value&#039;, function (done) {

            expect(function () {

                Joi.compile(undefined);
            }).to.throw(Error, &#039;Invalid schema content: &#039;);
            done();
        });

        it(&#039;shows path to errors in object&#039;, function (done) {

            var schema = {
                a: {
                    b: {
                        c: {
                            d: undefined
                        }
                    }
                }
            };

            expect(function () {

                Joi.compile(schema);
            }).to.throw(Error, &#039;Invalid schema content: (a.b.c.d)&#039;);
            done();
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
