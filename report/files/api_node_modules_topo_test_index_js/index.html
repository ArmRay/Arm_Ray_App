<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/topo/test/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/topo/test/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">266</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">67.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.40</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Code = require(&#039;code&#039;);
var Lab = require(&#039;lab&#039;);
var Hoek = require(&#039;hoek&#039;);
var Topo = require(&#039;..&#039;);


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.describe;
var it = lab.it;
var expect = Code.expect;


describe(&#039;Topo&#039;, function () {

    var testDeps = function (scenario) {

        var topo = new Topo();
        scenario.forEach(function (record, i) {

            var options = record.before || record.after || record.group ? { before: record.before, after: record.after, group: record.group } : null;
            topo.add(record.id, options);
        });

        return topo.nodes.join(&#039;&#039;);
    };

    it(&#039;sorts dependencies&#039;, function (done) {

        var scenario = [
            { id: &#039;0&#039;, before: &#039;a&#039; },
            { id: &#039;1&#039;, after: &#039;f&#039;, group: &#039;a&#039; },
            { id: &#039;2&#039;, before: &#039;a&#039; },
            { id: &#039;3&#039;, before: [&#039;b&#039;, &#039;c&#039;], group: &#039;a&#039; },
            { id: &#039;4&#039;, after: &#039;c&#039;, group: &#039;b&#039; },
            { id: &#039;5&#039;, group: &#039;c&#039; },
            { id: &#039;6&#039;, group: &#039;d&#039; },
            { id: &#039;7&#039;, group: &#039;e&#039; },
            { id: &#039;8&#039;, before: &#039;d&#039; },
            { id: &#039;9&#039;, after: &#039;c&#039;, group: &#039;a&#039; }
        ];

        expect(testDeps(scenario)).to.equal(&#039;0213547869&#039;);
        done();
    });

    it(&#039;sorts dependencies (before as array)&#039;, function (done) {

        var scenario = [
            { id: &#039;0&#039;, group: &#039;a&#039; },
            { id: &#039;1&#039;, group: &#039;b&#039; },
            { id: &#039;2&#039;, before: [&#039;a&#039;, &#039;b&#039;] }
        ];

        expect(testDeps(scenario)).to.equal(&#039;201&#039;);
        done();
    });

    it(&#039;sorts dependencies (after as array)&#039;, function (done) {

        var scenario = [
            { id: &#039;0&#039;, after: [&#039;a&#039;, &#039;b&#039;] },
            { id: &#039;1&#039;, group: &#039;a&#039; },
            { id: &#039;2&#039;, group: &#039;b&#039; }
        ];

        expect(testDeps(scenario)).to.equal(&#039;120&#039;);
        done();
    });


    it(&#039;sorts dependencies (seq)&#039;, function (done) {

        var scenario = [
            { id: &#039;0&#039; },
            { id: &#039;1&#039; },
            { id: &#039;2&#039; },
            { id: &#039;3&#039; }
        ];

        expect(testDeps(scenario)).to.equal(&#039;0123&#039;);
        done();
    });

    it(&#039;sorts dependencies (explicitly using after or before)&#039;, function (done) {

        var set = &#039;0123456789abcdefghijklmnopqrstuvwxyz&#039;;
        var groups = set.split(&#039;&#039;);

        // Use Fisher-Yates for shuffling

        var fisherYates = function (array) {

            var i = array.length;
            while (--i) {
                var j = Math.floor(Math.random() * (i + 1));
                var tempi = array[i];
                var tempj = array[j];
                array[i] = tempj;
                array[j] = tempi;
            }
        };

        var scenarioAfter = [];
        var scenarioBefore = [];
        for (var i = 0, il = groups.length; i &lt; il; ++i) {
            var item = {
                id: groups[i],
                group: groups[i]
            };
            var afterMod = {
                after: i ? groups.slice(0, i) : []
            };
            var beforeMod = {
                before: groups.slice(i + 1)
            };

            scenarioAfter.push(Hoek.applyToDefaults(item, afterMod));
            scenarioBefore.push(Hoek.applyToDefaults(item, beforeMod));
        }

        fisherYates(scenarioAfter);
        expect(testDeps(scenarioAfter)).to.equal(set);

        fisherYates(scenarioBefore);
        expect(testDeps(scenarioBefore)).to.equal(set);
        done();
    });

    it(&#039;throws on circular dependency&#039;, function (done) {

        var scenario = [
            { id: &#039;0&#039;, before: &#039;a&#039;, group: &#039;b&#039; },
            { id: &#039;1&#039;, before: &#039;c&#039;, group: &#039;a&#039; },
            { id: &#039;2&#039;, before: &#039;b&#039;, group: &#039;c&#039; }
        ];

        expect(function () {

            testDeps(scenario);
        }).to.throw(&#039;item added into group c created a dependencies error&#039;);

        done();
    });

    describe(&#039;merge()&#039;, function () {

        it(&#039;merges objects&#039;, function (done) {

            var topo = new Topo();
            topo.add(&#039;0&#039;, { before: &#039;a&#039; });
            topo.add(&#039;2&#039;, { before: &#039;a&#039; });
            topo.add(&#039;4&#039;, { after: &#039;c&#039;, group: &#039;b&#039; });
            topo.add(&#039;6&#039;, { group: &#039;d&#039; });
            topo.add(&#039;8&#039;, { before: &#039;d&#039; });
            expect(topo.nodes.join(&#039;&#039;)).to.equal(&#039;02486&#039;);

            var other = new Topo();
            other.add(&#039;1&#039;, { after: &#039;f&#039;, group: &#039;a&#039; });
            other.add(&#039;3&#039;, { before: [&#039;b&#039;, &#039;c&#039;], group: &#039;a&#039; });
            other.add(&#039;5&#039;, { group: &#039;c&#039; });
            other.add(&#039;7&#039;, { group: &#039;e&#039; });
            other.add(&#039;9&#039;, { after: &#039;c&#039;, group: &#039;a&#039; });
            expect(other.nodes.join(&#039;&#039;)).to.equal(&#039;13579&#039;);

            topo.merge(other);
            expect(topo.nodes.join(&#039;&#039;)).to.equal(&#039;0286135479&#039;);
            done();
        });

        it(&#039;merges objects (explicit sort)&#039;, function (done) {

            var topo = new Topo();
            topo.add(&#039;0&#039;, { before: &#039;a&#039;, sort: 1 });
            topo.add(&#039;2&#039;, { before: &#039;a&#039;, sort: 2 });
            topo.add(&#039;4&#039;, { after: &#039;c&#039;, group: &#039;b&#039;, sort: 3 });
            topo.add(&#039;6&#039;, { group: &#039;d&#039;, sort: 4 });
            topo.add(&#039;8&#039;, { before: &#039;d&#039;, sort: 5 });
            expect(topo.nodes.join(&#039;&#039;)).to.equal(&#039;02486&#039;);

            var other = new Topo();
            other.add(&#039;1&#039;, { after: &#039;f&#039;, group: &#039;a&#039;, sort: 6 });
            other.add(&#039;3&#039;, { before: [&#039;b&#039;, &#039;c&#039;], group: &#039;a&#039;, sort: 7 });
            other.add(&#039;5&#039;, { group: &#039;c&#039;, sort: 8 });
            other.add(&#039;7&#039;, { group: &#039;e&#039;, sort: 9 });
            other.add(&#039;9&#039;, { after: &#039;c&#039;, group: &#039;a&#039;, sort: 10 });
            expect(other.nodes.join(&#039;&#039;)).to.equal(&#039;13579&#039;);

            topo.merge(other);
            expect(topo.nodes.join(&#039;&#039;)).to.equal(&#039;0286135479&#039;);
            done();
        });

        it(&#039;merges objects (mixed sort)&#039;, function (done) {

            var topo = new Topo();
            topo.add(&#039;0&#039;, { before: &#039;a&#039;, sort: 1 });
            topo.add(&#039;2&#039;, { before: &#039;a&#039;, sort: 3 });
            topo.add(&#039;4&#039;, { after: &#039;c&#039;, group: &#039;b&#039;, sort: 5 });
            topo.add(&#039;6&#039;, { group: &#039;d&#039;, sort: 7 });
            topo.add(&#039;8&#039;, { before: &#039;d&#039;, sort: 9 });
            expect(topo.nodes.join(&#039;&#039;)).to.equal(&#039;02486&#039;);

            var other = new Topo();
            other.add(&#039;1&#039;, { after: &#039;f&#039;, group: &#039;a&#039;, sort: 2 });
            other.add(&#039;3&#039;, { before: [&#039;b&#039;, &#039;c&#039;], group: &#039;a&#039;, sort: 4 });
            other.add(&#039;5&#039;, { group: &#039;c&#039;, sort: 6 });
            other.add(&#039;7&#039;, { group: &#039;e&#039;, sort: 8 });
            other.add(&#039;9&#039;, { after: &#039;c&#039;, group: &#039;a&#039;, sort: 10 });
            expect(other.nodes.join(&#039;&#039;)).to.equal(&#039;13579&#039;);

            topo.merge(other);
            expect(topo.nodes.join(&#039;&#039;)).to.equal(&#039;0213547869&#039;);
            done();
        });

        it(&#039;merges objects (multiple)&#039;, function (done) {

            var topo1 = new Topo();
            topo1.add(&#039;0&#039;, { before: &#039;a&#039;, sort: 1 });
            topo1.add(&#039;2&#039;, { before: &#039;a&#039;, sort: 3 });
            topo1.add(&#039;4&#039;, { after: &#039;c&#039;, group: &#039;b&#039;, sort: 5 });

            var topo2 = new Topo();
            topo2.add(&#039;6&#039;, { group: &#039;d&#039;, sort: 7 });
            topo2.add(&#039;8&#039;, { before: &#039;d&#039;, sort: 9 });

            var other = new Topo();
            other.add(&#039;1&#039;, { after: &#039;f&#039;, group: &#039;a&#039;, sort: 2 });
            other.add(&#039;3&#039;, { before: [&#039;b&#039;, &#039;c&#039;], group: &#039;a&#039;, sort: 4 });
            other.add(&#039;5&#039;, { group: &#039;c&#039;, sort: 6 });
            other.add(&#039;7&#039;, { group: &#039;e&#039;, sort: 8 });
            other.add(&#039;9&#039;, { after: &#039;c&#039;, group: &#039;a&#039;, sort: 10 });
            expect(other.nodes.join(&#039;&#039;)).to.equal(&#039;13579&#039;);

            topo1.merge([topo2, null, other]);
            expect(topo1.nodes.join(&#039;&#039;)).to.equal(&#039;0213547869&#039;);
            done();
        });

        it(&#039;throws on circular dependency&#039;, function (done) {

            var topo = new Topo();
            topo.add(&#039;0&#039;, { before: &#039;a&#039;, group: &#039;b&#039; });
            topo.add(&#039;1&#039;, { before: &#039;c&#039;, group: &#039;a&#039; });

            var other = new Topo();
            other.add(&#039;2&#039;, { before: &#039;b&#039;, group: &#039;c&#039; });

            expect(function () {

                topo.merge(other);
            }).to.throw(&#039;merge created a dependencies error&#039;);

            done();
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
