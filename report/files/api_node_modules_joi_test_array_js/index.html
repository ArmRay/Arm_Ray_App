<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/joi/test/array.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/joi/test/array.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">74.78</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1049</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">60.83</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">13.45</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Lab = require(&#039;lab&#039;);
var Code = require(&#039;code&#039;);
var Joi = require(&#039;../lib&#039;);
var Helper = require(&#039;./helper&#039;);


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var describe = lab.describe;
var it = lab.it;
var expect = Code.expect;


describe(&#039;array&#039;, function () {

    it(&#039;converts a string to an array&#039;, function (done) {

        Joi.array().validate(&#039;[1,2,3]&#039;, function (err, value) {

            expect(err).to.not.exist();
            expect(value.length).to.equal(3);
            done();
        });
    });

    it(&#039;errors on non-array string&#039;, function (done) {

        Joi.array().validate(&#039;{ &quot;something&quot;: false }&#039;, function (err, value) {

            expect(err).to.exist();
            expect(err.message).to.equal(&#039;&quot;value&quot; must be an array&#039;);
            done();
        });
    });

    it(&#039;errors on number&#039;, function (done) {

        Joi.array().validate(3, function (err, value) {

            expect(err).to.exist();
            expect(value).to.equal(3);
            done();
        });
    });

    it(&#039;converts a non-array string with number type&#039;, function (done) {

        Joi.array().validate(&#039;3&#039;, function (err, value) {

            expect(err).to.exist();
            expect(value).to.equal(&#039;3&#039;);
            done();
        });
    });

    it(&#039;errors on a non-array string&#039;, function (done) {

        Joi.array().validate(&#039;asdf&#039;, function (err, value) {

            expect(err).to.exist();
            expect(value).to.equal(&#039;asdf&#039;);
            done();
        });
    });

    describe(&#039;#items&#039;, function () {

        it(&#039;converts members&#039;, function (done) {

            var schema = Joi.array().items(Joi.number());
            var input = [&#039;1&#039;, &#039;2&#039;, &#039;3&#039;];
            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([1, 2, 3]);
                done();
            });
        });

        it(&#039;shows path to errors in array items&#039;, function (done) {

            expect(function () {

                Joi.array().items({
                    a: {
                        b: {
                            c: {
                                d: undefined
                            }
                        }
                    }
                });
            }).to.throw(Error, &#039;Invalid schema content: (0.a.b.c.d)&#039;);

            expect(function () {

                Joi.array().items({ foo: &#039;bar&#039; }, undefined);
            }).to.throw(Error, &#039;Invalid schema content: (1)&#039;);

            done();
        });

        it(&#039;allows zero size&#039;, function (done) {

            var schema = Joi.object({
                test: Joi.array().items(Joi.object({
                    foo: Joi.string().required()
                }))
            });
            var input = { test: [] };

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                done();
            });
        });

        it(&#039;returns the first error when only one inclusion&#039;, function (done) {

            var schema = Joi.object({
                test: Joi.array().items(Joi.object({
                    foo: Joi.string().required()
                }))
            });
            var input = { test: [{ foo: &#039;a&#039; }, { bar: 2 }] };

            schema.validate(input, function (err, value) {

                expect(err.message).to.equal(&#039;child &quot;test&quot; fails because [&quot;test&quot; at position 1 fails because [child &quot;foo&quot; fails because [&quot;foo&quot; is required]]]&#039;);
                done();
            });
        });

        it(&#039;validates multiple types added in two calls&#039;, function (done) {

            var schema = Joi.array()
                .items(Joi.number())
                .items(Joi.string());

            Helper.validate(schema, [
                [[1, 2, 3], true],
                [[50, 100, 1000], true],
                [[1, &#039;a&#039;, 5, 10], true],
                [[&#039;joi&#039;, &#039;everydaylowprices&#039;, 5000], true]
            ], done);
        });

        it(&#039;validates multiple types with stripUnknown&#039;, function (done) {

            var schema = Joi.array().items(Joi.number(), Joi.string()).options({ stripUnknown: true });

            Helper.validate(schema, [
                [[1, 2, &#039;a&#039;], true, null, [1, 2, &#039;a&#039;]],
                [[1, { foo: &#039;bar&#039; }, &#039;a&#039;, 2], true, null, [1, &#039;a&#039;, 2]]
            ], done);
        });

        it(&#039;allows forbidden to restrict values&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).forbidden(), Joi.string());
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 3 contains an excluded value&#039;);
                done();
            });
        });

        it(&#039;validates that a required value exists&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).required(), Joi.string());
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; does not contain 1 required value(s)&#039;);
                done();
            });
        });

        it(&#039;validates that a required value exists with abortEarly = false&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).required(), Joi.string()).options({ abortEarly: false });
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; does not contain 1 required value(s)&#039;);
                done();
            });
        });

        it(&#039;does not re-run required tests that have already been matched&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).required(), Joi.string());
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;, &#039;four&#039;, &#039;four&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal(input);
                done();
            });
        });

        it(&#039;does not re-run required tests that have already failed&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).required(), Joi.boolean().required(), Joi.number());
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;, &#039;four&#039;, &#039;four&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 0 does not match any of the allowed types&#039;);
                done();
            });
        });

        it(&#039;can require duplicates of the same schema and fail&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).required(), Joi.string().valid(&#039;four&#039;).required(), Joi.string());
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; does not contain 1 required value(s)&#039;);
                done();
            });
        });

        it(&#039;can require duplicates of the same schema and pass&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().valid(&#039;four&#039;).required(), Joi.string().valid(&#039;four&#039;).required(), Joi.string());
            var input = [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;, &#039;four&#039;, &#039;four&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal(input);
                done();
            });
        });

        it(&#039;continues to validate after a required match&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().required(), Joi.boolean());
            var input = [true, &#039;one&#039;, false, &#039;two&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal(input);
                done();
            });
        });

        it(&#039;can use a label on a required parameter&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().required().label(&#039;required string&#039;), Joi.boolean());
            var input = [true, false];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; does not contain [required string]&#039;);
                done();
            });
        });

        it(&#039;can use a label on one required parameter, and no label on another&#039;, function (done) {

            var schema = Joi.array().items(Joi.string().required().label(&#039;required string&#039;), Joi.string().required(), Joi.boolean());
            var input = [true, false];

            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; does not contain [required string] and 1 other required value(s)&#039;);
                done();
            });
        });

        it(&#039;can strip matching items&#039;, function (done) {

            var schema = Joi.array().items(Joi.string(), Joi.any().strip());
            schema.validate([&#039;one&#039;, &#039;two&#039;, 3, 4], function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;one&#039;, &#039;two&#039;]);
                done();
            });
        });
    });

    describe(&#039;#min&#039;, function () {

        it(&#039;validates array size&#039;, function (done) {

            var schema = Joi.array().min(2);
            Helper.validate(schema, [
                [[1, 2], true],
                [[1], false]
            ], done);
        });

        it(&#039;throws when limit is not a number&#039;, function (done) {

            expect(function () {

                Joi.array().min(&#039;a&#039;);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });

        it(&#039;throws when limit is not an integer&#039;, function (done) {

            expect(function () {

                Joi.array().min(1.2);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });
    });

    describe(&#039;#max&#039;, function () {

        it(&#039;validates array size&#039;, function (done) {

            var schema = Joi.array().max(1);
            Helper.validate(schema, [
                [[1, 2], false],
                [[1], true]
            ], done);
        });

        it(&#039;throws when limit is not a number&#039;, function (done) {

            expect(function () {

                Joi.array().max(&#039;a&#039;);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });

        it(&#039;throws when limit is not an integer&#039;, function (done) {

            expect(function () {

                Joi.array().max(1.2);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });
    });

    describe(&#039;#length&#039;, function () {

        it(&#039;validates array size&#039;, function (done) {

            var schema = Joi.array().length(2);
            Helper.validate(schema, [
                [[1, 2], true],
                [[1], false]
            ], done);
        });

        it(&#039;throws when limit is not a number&#039;, function (done) {

            expect(function () {

                Joi.array().length(&#039;a&#039;);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });

        it(&#039;throws when limit is not an integer&#039;, function (done) {

            expect(function () {

                Joi.array().length(1.2);
            }).to.throw(&#039;limit must be a positive integer&#039;);
            done();
        });
    });

    describe(&#039;#validate&#039;, function () {

        it(&#039;should, by default, allow undefined, allow empty array&#039;, function (done) {

            Helper.validate(Joi.array(), [
                [undefined, true],
                [[], true]
            ], done);
        });

        it(&#039;should, when .required(), deny undefined&#039;, function (done) {

            Helper.validate(Joi.array().required(), [
                [undefined, false]
            ], done);
        });

        it(&#039;allows empty arrays&#039;, function (done) {

            Helper.validate(Joi.array(), [
                [undefined, true],
                [[], true]
            ], done);
        });

        it(&#039;excludes values when items are forbidden&#039;, function (done) {

            Helper.validate(Joi.array().items(Joi.string().forbidden()), [
                [[&#039;2&#039;, &#039;1&#039;], false],
                [[&#039;1&#039;], false],
                [[2], true]
            ], done);
        });

        it(&#039;allows types to be forbidden&#039;, function (done) {

            var schema = Joi.array().items(Joi.number().forbidden());

            var n = [1, 2, &#039;hippo&#039;];
            schema.validate(n, function (err, value) {

                expect(err).to.exist();

                var m = [&#039;x&#039;, &#039;y&#039;, &#039;z&#039;];
                schema.validate(m, function (err2, value2) {

                    expect(err2).to.not.exist();
                    done();
                });
            });
        });

        it(&#039;validates array of Numbers&#039;, function (done) {

            Helper.validate(Joi.array().items(Joi.number()), [
                [[1, 2, 3], true],
                [[50, 100, 1000], true],
                [[&#039;a&#039;, 1, 2], false],
                [[&#039;1&#039;, &#039;2&#039;, 4], true]
            ], done);
        });

        it(&#039;validates array of mixed Numbers &amp; Strings&#039;, function (done) {

            Helper.validate(Joi.array().items(Joi.number(), Joi.string()), [
                [[1, 2, 3], true],
                [[50, 100, 1000], true],
                [[1, &#039;a&#039;, 5, 10], true],
                [[&#039;joi&#039;, &#039;everydaylowprices&#039;, 5000], true]
            ], done);
        });

        it(&#039;validates array of objects with schema&#039;, function (done) {

            Helper.validate(Joi.array().items(Joi.object({ h1: Joi.number().required() })), [
                [[{ h1: 1 }, { h1: 2 }, { h1: 3 }], true],
                [[{ h2: 1, h3: &#039;somestring&#039; }, { h1: 2 }, { h1: 3 }], false],
                [[1, 2, [1]], false]
            ], done);
        });

        it(&#039;errors on array of unallowed mixed types (Array)&#039;, function (done) {

            Helper.validate(Joi.array().items(Joi.number()), [
                [[1, 2, 3], true],
                [[1, 2, [1]], false]
            ], done);
        });

        it(&#039;errors on invalid number rule using includes&#039;, function (done) {

            var schema = Joi.object({
                arr: Joi.array().items(Joi.number().integer())
            });

            var input = { arr: [1, 2, 2.1] };
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;child &quot;arr&quot; fails because [&quot;arr&quot; at position 2 fails because [&quot;2&quot; must be an integer]]&#039;);
                done();
            });
        });

        it(&#039;validates an array within an object&#039;, function (done) {

            var schema = Joi.object({
                array: Joi.array().items(Joi.string().min(5), Joi.number().min(3))
            }).options({ convert: false });

            Helper.validate(schema, [
                [{ array: [&#039;12345&#039;] }, true],
                [{ array: [&#039;1&#039;] }, false],
                [{ array: [3] }, true],
                [{ array: [&#039;12345&#039;, 3] }, true]
            ], done);
        });

        it(&#039;should not change original value&#039;, function (done) {

            var schema = Joi.array().items(Joi.number()).unique();
            var input = [&#039;1&#039;, &#039;2&#039;];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([1, 2]);
                expect(input).to.deep.equal([&#039;1&#039;, &#039;2&#039;]);
                done();
            });
        });

        it(&#039;should have multiple errors if abort early is false&#039;, function (done) {

            var schema = Joi.array().items(Joi.number(), Joi.object()).items(Joi.boolean().forbidden());
            var input = [1, undefined, true, &#039;a&#039;];

            Joi.validate(input, schema, { abortEarly: false }, function (err, value) {

                expect(err).to.exist();
                expect(err).to.have.length(4);
                expect(err.details).to.deep.equal([{
                    message: &#039;&quot;value&quot; must not be a sparse array&#039;,
                    path: &#039;1&#039;,
                    type: &#039;array.sparse&#039;,
                    context: {
                        key: &#039;value&#039;
                    }
                }, {
                    message: &#039;&quot;value&quot; at position 2 contains an excluded value&#039;,
                    path: &#039;2&#039;,
                    type: &#039;array.excludes&#039;,
                    context: {
                        pos: 2,
                        key: &#039;value&#039;,
                        value: true
                    }
                }, {
                    message: &#039;&quot;value&quot; at position 3 does not match any of the allowed types&#039;,
                    path: &#039;3&#039;,
                    type: &#039;array.includes&#039;,
                    context: {
                        pos: 3,
                        key: &#039;value&#039;,
                        value: &#039;a&#039;
                    }
                }]);
                done();
            });
        });
    });

    describe(&#039;#describe&#039;, function () {

        it(&#039;returns an empty description when no rules are applied&#039;, function (done) {

            var schema = Joi.array();
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: false }
            });
            done();
        });

        it(&#039;returns an updated description when sparse rule is applied&#039;, function (done) {

            var schema = Joi.array().sparse();
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: true }
            });
            done();
        });

        it(&#039;returns an items array only if items are specified&#039;, function (done) {

            var schema = Joi.array().items().max(5);
            var desc = schema.describe();
            expect(desc.items).to.not.exist();
            done();
        });

        it(&#039;returns a recursively defined array of items when specified&#039;, function (done) {

            var schema = Joi.array()
                .items(Joi.number(), Joi.string())
                .items(Joi.boolean().forbidden())
                .ordered(Joi.number(), Joi.string())
                .ordered(Joi.string().required());
            var desc = schema.describe();
            expect(desc.items).to.have.length(3);
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: false },
                orderedItems: [{ type: &#039;number&#039;, invalids: [Infinity, -Infinity] }, { type: &#039;string&#039;, invalids: [&#039;&#039;] }, { type: &#039;string&#039;, invalids: [&#039;&#039;], flags: { presence: &#039;required&#039; } }],
                items: [{ type: &#039;number&#039;, invalids: [Infinity, -Infinity] }, { type: &#039;string&#039;, invalids: [&#039;&#039;] }, { type: &#039;boolean&#039;, flags: { presence: &#039;forbidden&#039; } }]
            });

            done();
        });
    });

    describe(&#039;#unique&#039;, function () {

        it(&#039;errors if duplicate numbers, strings, objects, binaries, functions, dates and booleans&#039;, function (done) {

            var buffer = new Buffer(&#039;hello world&#039;);
            var func = function () {};
            var now = new Date();
            var schema = Joi.array().sparse().unique();

            Helper.validate(schema, [
                [[2, 2], false],
                [[02, 2], false], // eslint-disable-line no-octal
                [[0x2, 2], false],
                [[&#039;duplicate&#039;, &#039;duplicate&#039;], false],
                [[{ a: &#039;b&#039; }, { a: &#039;b&#039; }], false],
                [[buffer, buffer], false],
                [[func, func], false],
                [[now, now], false],
                [[true, true], false],
                [[undefined, undefined], false]
            ], done);
        });

        it(&#039;ignores duplicates if they are of different types&#039;, function (done) {

            var schema = Joi.array().unique();

            Helper.validate(schema, [
                [[2, &#039;2&#039;], true]
            ], done);
        });

        it(&#039;validates without duplicates&#039;, function (done) {

            var buffer = new Buffer(&#039;hello world&#039;);
            var buffer2 = new Buffer(&#039;Hello world&#039;);
            var func = function () {};
            var func2 = function () {};
            var now = new Date();
            var now2 = new Date(+now + 100);
            var schema = Joi.array().unique();

            Helper.validate(schema, [
                [[1, 2], true],
                [[&#039;s1&#039;, &#039;s2&#039;], true],
                [[{ a: &#039;b&#039; }, { a: &#039;c&#039; }], true],
                [[buffer, buffer2], true],
                [[func, func2], true],
                [[now, now2], true],
                [[true, false], true]
            ], done);
        });
    });

    describe(&#039;#sparse&#039;, function () {

        it(&#039;errors on undefined value&#039;, function (done) {

            var schema = Joi.array().items(Joi.number());

            Helper.validate(schema, [
                [[undefined], false],
                [[2, undefined], false]
            ], done);
        });

        it(&#039;validates on undefined value with sparse&#039;, function (done) {

            var schema = Joi.array().items(Joi.number()).sparse();

            Helper.validate(schema, [
                [[undefined], true],
                [[2, undefined], true]
            ], done);
        });

        it(&#039;switches the sparse flag&#039;, function (done) {

            var schema = Joi.array().sparse();
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: true }
            });
            done();
        });

        it(&#039;switches the sparse flag with explicit value&#039;, function (done) {

            var schema = Joi.array().sparse(true);
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: true }
            });
            done();
        });

        it(&#039;switches the sparse flag back&#039;, function (done) {

            var schema = Joi.array().sparse().sparse(false);
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: false }
            });
            done();
        });
    });

    describe(&#039;#single&#039;, function () {

        it(&#039;should allow a single element&#039;, function (done) {

            var schema = Joi.array().items(Joi.number()).items(Joi.boolean().forbidden()).single();

            Helper.validate(schema, [
                [[1, 2, 3], true],
                [1, true],
                [[&#039;a&#039;], false, null, &#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be a number]&#039;],
                [&#039;a&#039;, false, null, &#039;single value of &quot;value&quot; fails because [&quot;0&quot; must be a number]&#039;],
                [true, false, null, &#039;single value of &quot;value&quot; contains an excluded value&#039;]
            ], done);
        });

        it(&#039;should allow a single element with multiple types&#039;, function (done) {

            var schema = Joi.array().items(Joi.number(), Joi.string()).single();

            Helper.validate(schema, [
                [[1, 2, 3], true],
                [1, true],
                [[1, &#039;a&#039;], true],
                [&#039;a&#039;, true],
                [true, false, null, &#039;single value of &quot;value&quot; does not match any of the allowed types&#039;]
            ], done);
        });

        it(&#039;should allow nested arrays&#039;, function (done) {

            var schema = Joi.array().items(Joi.array().items(Joi.number())).single();

            Helper.validate(schema, [
                [[[1], [2], [3]], true],
                [[1, 2, 3], true],
                [[[&#039;a&#039;]], false, null, &#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; at position 0 fails because [&quot;0&quot; must be a number]]&#039;],
                [[&#039;a&#039;], false, null, &#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be an array]&#039;],
                [&#039;a&#039;, false, null, &#039;single value of &quot;value&quot; fails because [&quot;0&quot; must be an array]&#039;],
                [1, false, null, &#039;single value of &quot;value&quot; fails because [&quot;0&quot; must be an array]&#039;],
                [true, false, null, &#039;single value of &quot;value&quot; fails because [&quot;0&quot; must be an array]&#039;]
            ], done);
        });

        it(&#039;should allow nested arrays with multiple types&#039;, function (done) {

            var schema = Joi.array().items(Joi.array().items(Joi.number(), Joi.boolean())).single();

            Helper.validate(schema, [
                [[[1, true]], true],
                [[1, true], true],
                [[[1, &#039;a&#039;]], false, null, &#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; at position 1 does not match any of the allowed types]&#039;],
                [[1, &#039;a&#039;], false, null, &#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be an array]&#039;]
            ], done);
        });

        it(&#039;switches the single flag with explicit value&#039;, function (done) {

            var schema = Joi.array().single(true);
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: false, single: true }
            });
            done();
        });

        it(&#039;switches the single flag back&#039;, function (done) {

            var schema = Joi.array().single().single(false);
            var desc = schema.describe();
            expect(desc).to.deep.equal({
                type: &#039;array&#039;,
                flags: { sparse: false, single: false }
            });
            done();
        });
    });

    describe(&#039;#options&#039;, function () {

        it(&#039;respects stripUnknown&#039;, function (done) {

            var schema = Joi.array().items(Joi.string()).options({ stripUnknown: true });
            schema.validate([&#039;one&#039;, &#039;two&#039;, 3, 4, true, false], function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;one&#039;, &#039;two&#039;]);
                done();
            });
        });
    });

    describe(&#039;#ordered&#039;, function () {

        it(&#039;shows path to errors in array ordered items&#039;, function (done) {

            expect(function () {

                Joi.array().ordered({
                    a: {
                        b: {
                            c: {
                                d: undefined
                            }
                        }
                    }
                });
            }).to.throw(Error, &#039;Invalid schema content: (0.a.b.c.d)&#039;);

            expect(function () {

                Joi.array().ordered({ foo: &#039;bar&#039; }, undefined);
            }).to.throw(Error, &#039;Invalid schema content: (1)&#039;);

            done();
        });

        it(&#039;validates input against items in order&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().required()]);
            var input = [&#039;s1&#039;, 2];
            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, 2]);
                done();
            });
        });

        it(&#039;validates input with optional item&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().required(), Joi.number()]);
            var input = [&#039;s1&#039;, 2, 3];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, 2, 3]);
                done();
            });
        });

        it(&#039;validates input without optional item&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().required(), Joi.number()]);
            var input = [&#039;s1&#039;, 2];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, 2]);
                done();
            });
        });

        it(&#039;validates input without optional item&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().required(), Joi.number()]).sparse(true);
            var input = [&#039;s1&#039;, 2, undefined];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, 2, undefined]);
                done();
            });
        });

        it(&#039;validates input without optional item in a sparse array&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number(), Joi.number().required()]).sparse(true);
            var input = [&#039;s1&#039;, undefined, 3];

            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, undefined, 3]);
                done();
            });
        });

        it(&#039;validates when input matches ordered items and matches regular items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().required()]).items(Joi.number());
            var input = [&#039;s1&#039;, 2, 3, 4, 5];
            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, 2, 3, 4, 5]);
                done();
            });
        });

        it(&#039;errors when input does not match ordered items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.number().required(), Joi.string().required()]);
            var input = [&#039;s1&#039;, 2];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be a number]&#039;);
                done();
            });
        });

        it(&#039;errors when input has more items than ordered items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.number().required(), Joi.string().required()]);
            var input = [1, &#039;s2&#039;, 3];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 2 fails because array must contain at most 2 items&#039;);
                done();
            });
        });

        it(&#039;errors when input has more items than ordered items with abortEarly = false&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string(), Joi.number()]).options({ abortEarly: false });
            var input = [1, 2, 3, 4, 5];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be a string]. &quot;value&quot; at position 2 fails because array must contain at most 2 items. &quot;value&quot; at position 3 fails because array must contain at most 2 items. &quot;value&quot; at position 4 fails because array must contain at most 2 items&#039;);
                expect(err.details).to.have.length(4);
                done();
            });
        });

        it(&#039;errors when input has less items than ordered items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.number().required(), Joi.string().required()]);
            var input = [1];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; does not contain 1 required value(s)&#039;);
                done();
            });
        });

        it(&#039;errors when input matches ordered items but not matches regular items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().required()]).items(Joi.number()).options({ abortEarly: false });
            var input = [&#039;s1&#039;, 2, 3, 4, &#039;s5&#039;];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 4 fails because [&quot;4&quot; must be a number]&#039;);
                done();
            });
        });

        it(&#039;errors when input does not match ordered items but matches regular items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string(), Joi.number()]).items(Joi.number()).options({ abortEarly: false });
            var input = [1, 2, 3, 4, 5];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be a string]&#039;);
                done();
            });
        });

        it(&#039;errors when input does not match ordered items not matches regular items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string(), Joi.number()]).items(Joi.string()).options({ abortEarly: false });
            var input = [1, 2, 3, 4, 5];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be a string]. &quot;value&quot; at position 2 fails because [&quot;2&quot; must be a string]. &quot;value&quot; at position 3 fails because [&quot;3&quot; must be a string]. &quot;value&quot; at position 4 fails because [&quot;4&quot; must be a string]&#039;);
                expect(err.details).to.have.length(4);
                done();
            });
        });

        it(&#039;errors but continues when abortEarly is set to false&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.number().required(), Joi.string().required()]).options({ abortEarly: false });
            var input = [&#039;s1&#039;, 2];
            schema.validate(input, function (err, value) {

                expect(err).to.exist();
                expect(err.message).to.equal(&#039;&quot;value&quot; at position 0 fails because [&quot;0&quot; must be a number]. &quot;value&quot; at position 1 fails because [&quot;1&quot; must be a string]&#039;);
                expect(err.details).to.have.length(2);
                done();
            });
        });

        it(&#039;strips item&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().required(), Joi.number().strip(), Joi.number().required()]);
            var input = [&#039;s1&#039;, 2, 3];
            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([&#039;s1&#039;, 3]);
                done();
            });
        });

        it(&#039;strips multiple items&#039;, function (done) {

            var schema = Joi.array().ordered([Joi.string().strip(), Joi.number(), Joi.number().strip()]);
            var input = [&#039;s1&#039;, 2, 3];
            schema.validate(input, function (err, value) {

                expect(err).to.not.exist();
                expect(value).to.deep.equal([2]);
                done();
            });
        });
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
