<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/joi/lib/object.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/joi/lib/object.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">754</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">139.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Load modules

var Hoek = require(&#039;hoek&#039;);
var Topo = require(&#039;topo&#039;);
var Any = require(&#039;./any&#039;);
var Cast = require(&#039;./cast&#039;);
var Errors = require(&#039;./errors&#039;);


// Declare internals

var internals = {};


internals.Object = function () {

    Any.call(this);
    this._type = &#039;object&#039;;
    this._inner.children = null;
    this._inner.renames = [];
    this._inner.dependencies = [];
    this._inner.patterns = [];
};

Hoek.inherits(internals.Object, Any);


internals.Object.prototype._base = function (value, state, options) {

    var item, key, localState, result;
    var target = value;
    var errors = [];
    var finish = function () {

        return {
            value: target,
            errors: errors.length ? errors : null
        };
    };

    if (typeof value === &#039;string&#039; &amp;&amp;
        options.convert) {

        try {
            value = JSON.parse(value);
        }
        catch (parseErr) { }
    }

    var type = this._flags.func ? &#039;function&#039; : &#039;object&#039;;
    if (!value ||
        typeof value !== type ||
        Array.isArray(value)) {

        errors.push(Errors.create(type + &#039;.base&#039;, null, state, options));
        return finish();
    }

    // Skip if there are no other rules to test

    if (!this._inner.renames.length &amp;&amp;
        !this._inner.dependencies.length &amp;&amp;
        !this._inner.children &amp;&amp;                    // null allows any keys
        !this._inner.patterns.length) {

        target = value;
        return finish();
    }

    // Ensure target is a local copy (parsed) or shallow copy

    if (target === value) {
        if (type === &#039;object&#039;) {
            target = Object.create(Object.getPrototypeOf(value));
        }
        else {
            target = function () {

                return value.apply(this, arguments);
            };

            target.prototype = Hoek.clone(value.prototype);
        }

        var valueKeys = Object.keys(value);
        for (var t = 0, tl = valueKeys.length; t &lt; tl; ++t) {
            target[valueKeys[t]] = value[valueKeys[t]];
        }
    }
    else {
        target = value;
    }

    // Rename keys

    var renamed = {};
    for (var r = 0, rl = this._inner.renames.length; r &lt; rl; ++r) {
        item = this._inner.renames[r];

        if (item.options.ignoreUndefined &amp;&amp; target[item.from] === undefined) {
            continue;
        }

        if (!item.options.multiple &amp;&amp;
            renamed[item.to]) {

            errors.push(Errors.create(&#039;object.rename.multiple&#039;, { from: item.from, to: item.to }, state, options));
            if (options.abortEarly) {
                return finish();
            }
        }

        if (Object.prototype.hasOwnProperty.call(target, item.to) &amp;&amp;
            !item.options.override &amp;&amp;
            !renamed[item.to]) {

            errors.push(Errors.create(&#039;object.rename.override&#039;, { from: item.from, to: item.to }, state, options));
            if (options.abortEarly) {
                return finish();
            }
        }

        if (target[item.from] === undefined) {
            delete target[item.to];
        }
        else {
            target[item.to] = target[item.from];
        }

        renamed[item.to] = true;

        if (!item.options.alias) {
            delete target[item.from];
        }
    }

    // Validate schema

    if (!this._inner.children &amp;&amp;            // null allows any keys
        !this._inner.patterns.length &amp;&amp;
        !this._inner.dependencies.length) {

        return finish();
    }

    var unprocessed = Hoek.mapToObject(Object.keys(target));

    if (this._inner.children) {
        for (var i = 0, il = this._inner.children.length; i &lt; il; ++i) {
            var child = this._inner.children[i];
            key = child.key;
            item = target[key];

            delete unprocessed[key];

            localState = { key: key, path: (state.path || &#039;&#039;) + (state.path &amp;&amp; key ? &#039;.&#039; : &#039;&#039;) + key, parent: target, reference: state.reference };
            result = child.schema._validate(item, localState, options);
            if (result.errors) {
                errors.push(Errors.create(&#039;object.child&#039;, { key: key, reason: result.errors }, localState, options));

                if (options.abortEarly) {
                    return finish();
                }
            }

            if (child.schema._flags.strip || (result.value === undefined &amp;&amp; result.value !== item)) {
                delete target[key];
            }
            else if (result.value !== undefined) {
                target[key] = result.value;
            }
        }
    }

    // Unknown keys

    var unprocessedKeys = Object.keys(unprocessed);
    if (unprocessedKeys.length &amp;&amp;
        this._inner.patterns.length) {

        for (i = 0, il = unprocessedKeys.length; i &lt; il; ++i) {
            key = unprocessedKeys[i];

            for (var p = 0, pl = this._inner.patterns.length; p &lt; pl; ++p) {
                var pattern = this._inner.patterns[p];

                if (pattern.regex.test(key)) {
                    delete unprocessed[key];

                    item = target[key];
                    localState = { key: key, path: (state.path ? state.path + &#039;.&#039; : &#039;&#039;) + key, parent: target, reference: state.reference };
                    result = pattern.rule._validate(item, localState, options);
                    if (result.errors) {
                        errors.push(Errors.create(&#039;object.child&#039;, { key: key, reason: result.errors }, localState, options));

                        if (options.abortEarly) {
                            return finish();
                        }
                    }

                    if (result.value !== undefined) {
                        target[key] = result.value;
                    }
                }
            }
        }

        unprocessedKeys = Object.keys(unprocessed);
    }

    if ((this._inner.children || this._inner.patterns.length) &amp;&amp; unprocessedKeys.length) {
        if (options.stripUnknown ||
            options.skipFunctions) {

            for (var k = 0, kl = unprocessedKeys.length; k &lt; kl; ++k) {
                key = unprocessedKeys[k];

                if (options.stripUnknown) {
                    delete target[key];
                    delete unprocessed[key];
                }
                else if (typeof target[key] === &#039;function&#039;) {
                    delete unprocessed[key];
                }
            }

            unprocessedKeys = Object.keys(unprocessed);
        }

        if (unprocessedKeys.length &amp;&amp;
            (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {

            for (var e = 0, el = unprocessedKeys.length; e &lt; el; ++e) {
                errors.push(Errors.create(&#039;object.allowUnknown&#039;, null, { key: unprocessedKeys[e], path: state.path + (state.path ? &#039;.&#039; : &#039;&#039;) + unprocessedKeys[e] }, options));
            }
        }
    }

    // Validate dependencies

    for (var d = 0, dl = this._inner.dependencies.length; d &lt; dl; ++d) {
        var dep = this._inner.dependencies[d];
        var err = internals[dep.type](dep.key !== null &amp;&amp; value[dep.key], dep.peers, target, { key: dep.key, path: (state.path || &#039;&#039;) + (dep.key ? &#039;.&#039; + dep.key : &#039;&#039;) }, options);
        if (err) {
            errors.push(err);
            if (options.abortEarly) {
                return finish();
            }
        }
    }

    return finish();
};


internals.Object.prototype._func = function () {

    var obj = this.clone();
    obj._flags.func = true;
    return obj;
};


internals.Object.prototype.keys = function (schema) {

    Hoek.assert(schema === null || schema === undefined || typeof schema === &#039;object&#039;, &#039;Object schema must be a valid object&#039;);
    Hoek.assert(!schema || !schema.isJoi, &#039;Object schema cannot be a joi schema&#039;);

    var obj = this.clone();

    if (!schema) {
        obj._inner.children = null;
        return obj;
    }

    var children = Object.keys(schema);

    if (!children.length) {
        obj._inner.children = [];
        return obj;
    }

    var topo = new Topo();
    var child;
    if (obj._inner.children) {
        for (var i = 0, il = obj._inner.children.length; i &lt; il; ++i) {
            child = obj._inner.children[i];

            // Only add the key if we are not going to replace it later
            if (children.indexOf(child.key) === -1) {
                topo.add(child, { after: child._refs, group: child.key });
            }
        }
    }

    for (var c = 0, cl = children.length; c &lt; cl; ++c) {
        var key = children[c];
        child = schema[key];
        try {
            var cast = Cast.schema(child);
            topo.add({ key: key, schema: cast }, { after: cast._refs, group: key });
        }
        catch (castErr) {
            if (castErr.hasOwnProperty(&#039;path&#039;)) {
                castErr.path = key + &#039;.&#039; + castErr.path;
            }
            else {
                castErr.path = key;
            }
            throw castErr;
        }
    }

    obj._inner.children = topo.nodes;

    return obj;
};


internals.Object.prototype.unknown = function (allow) {

    var obj = this.clone();
    obj._flags.allowUnknown = (allow !== false);
    return obj;
};


internals.Object.prototype.length = function (limit) {

    Hoek.assert(Hoek.isInteger(limit) &amp;&amp; limit &gt;= 0, &#039;limit must be a positive integer&#039;);

    return this._test(&#039;length&#039;, limit, function (value, state, options) {

        if (Object.keys(value).length === limit) {
            return null;
        }

        return Errors.create(&#039;object.length&#039;, { limit: limit }, state, options);
    });
};


internals.Object.prototype.min = function (limit) {

    Hoek.assert(Hoek.isInteger(limit) &amp;&amp; limit &gt;= 0, &#039;limit must be a positive integer&#039;);

    return this._test(&#039;min&#039;, limit, function (value, state, options) {

        if (Object.keys(value).length &gt;= limit) {
            return null;
        }

        return Errors.create(&#039;object.min&#039;, { limit: limit }, state, options);
    });
};


internals.Object.prototype.max = function (limit) {

    Hoek.assert(Hoek.isInteger(limit) &amp;&amp; limit &gt;= 0, &#039;limit must be a positive integer&#039;);

    return this._test(&#039;max&#039;, limit, function (value, state, options) {

        if (Object.keys(value).length &lt;= limit) {
            return null;
        }

        return Errors.create(&#039;object.max&#039;, { limit: limit }, state, options);
    });
};


internals.Object.prototype.pattern = function (pattern, schema) {

    Hoek.assert(pattern instanceof RegExp, &#039;Invalid regular expression&#039;);
    Hoek.assert(schema !== undefined, &#039;Invalid rule&#039;);

    pattern = new RegExp(pattern.source, pattern.ignoreCase ? &#039;i&#039; : undefined);         // Future version should break this and forbid unsupported regex flags

    try {
        schema = Cast.schema(schema);
    }
    catch (castErr) {
        if (castErr.hasOwnProperty(&#039;path&#039;)) {
            castErr.message += &#039;(&#039; + castErr.path + &#039;)&#039;;
        }

        throw castErr;
    }


    var obj = this.clone();
    obj._inner.patterns.push({ regex: pattern, rule: schema });
    return obj;
};


internals.Object.prototype.with = function (key, peers) {

    return this._dependency(&#039;with&#039;, key, peers);
};


internals.Object.prototype.without = function (key, peers) {

    return this._dependency(&#039;without&#039;, key, peers);
};


internals.Object.prototype.xor = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency(&#039;xor&#039;, null, peers);
};


internals.Object.prototype.or = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency(&#039;or&#039;, null, peers);
};


internals.Object.prototype.and = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency(&#039;and&#039;, null, peers);
};


internals.Object.prototype.nand = function () {

    var peers = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this._dependency(&#039;nand&#039;, null, peers);
};


internals.Object.prototype.requiredKeys = function (children) {

    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, &#039;required&#039;);
};


internals.Object.prototype.optionalKeys = function (children) {

    children = Hoek.flatten(Array.prototype.slice.call(arguments));
    return this.applyFunctionToChildren(children, &#039;optional&#039;);
};


internals.renameDefaults = {
    alias: false,                   // Keep old value in place
    multiple: false,                // Allow renaming multiple keys into the same target
    override: false                 // Overrides an existing key
};


internals.Object.prototype.rename = function (from, to, options) {

    Hoek.assert(typeof from === &#039;string&#039;, &#039;Rename missing the from argument&#039;);
    Hoek.assert(typeof to === &#039;string&#039;, &#039;Rename missing the to argument&#039;);
    Hoek.assert(to !== from, &#039;Cannot rename key to same name:&#039;, from);

    for (var i = 0, il = this._inner.renames.length; i &lt; il; ++i) {
        Hoek.assert(this._inner.renames[i].from !== from, &#039;Cannot rename the same key multiple times&#039;);
    }

    var obj = this.clone();

    obj._inner.renames.push({
        from: from,
        to: to,
        options: Hoek.applyToDefaults(internals.renameDefaults, options || {})
    });

    return obj;
};


internals.groupChildren = function (children) {

    children.sort();

    var grouped = {};

    for (var c = 0, lc = children.length; c &lt; lc; c++) {
        var child = children[c];
        Hoek.assert(typeof child === &#039;string&#039;, &#039;children must be strings&#039;);
        var group = child.split(&#039;.&#039;)[0];
        var childGroup = grouped[group] = (grouped[group] || []);
        childGroup.push(child.substring(group.length + 1));
    }

    return grouped;
};


internals.Object.prototype.applyFunctionToChildren = function (children, fn, args, root) {

    children = [].concat(children);
    Hoek.assert(children.length &gt; 0, &#039;expected at least one children&#039;);

    var groupedChildren = internals.groupChildren(children);
    var obj;

    if (&#039;&#039; in groupedChildren) {
        obj = this[fn].apply(this, args);
        delete groupedChildren[&#039;&#039;];
    }
    else {
        obj = this.clone();
    }

    if (obj._inner.children) {
        root = root ? (root + &#039;.&#039;) : &#039;&#039;;

        for (var i = 0, il = obj._inner.children.length; i &lt; il; ++i) {
            var child = obj._inner.children[i];
            var group = groupedChildren[child.key];

            if (group) {
                obj._inner.children[i] = {
                    key: child.key,
                    _refs: child._refs,
                    schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                };

                delete groupedChildren[child.key];
            }
        }
    }

    var remaining = Object.keys(groupedChildren);
    Hoek.assert(remaining.length === 0, &#039;unknown key(s)&#039;, remaining.join(&#039;, &#039;));

    return obj;
};


internals.Object.prototype._dependency = function (type, key, peers) {

    peers = [].concat(peers);
    for (var i = 0, li = peers.length; i &lt; li; i++) {
        Hoek.assert(typeof peers[i] === &#039;string&#039;, type, &#039;peers must be a string or array of strings&#039;);
    }

    var obj = this.clone();
    obj._inner.dependencies.push({ type: type, key: key, peers: peers });
    return obj;
};


internals.with = function (value, peers, parent, state, options) {

    if (value === undefined) {
        return null;
    }

    for (var i = 0, il = peers.length; i &lt; il; ++i) {
        var peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||
            parent[peer] === undefined) {

            return Errors.create(&#039;object.with&#039;, { peer: peer }, state, options);
        }
    }

    return null;
};


internals.without = function (value, peers, parent, state, options) {

    if (value === undefined) {
        return null;
    }

    for (var i = 0, il = peers.length; i &lt; il; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &amp;&amp;
            parent[peer] !== undefined) {

            return Errors.create(&#039;object.without&#039;, { peer: peer }, state, options);
        }
    }

    return null;
};


internals.xor = function (value, peers, parent, state, options) {

    var present = [];
    for (var i = 0, il = peers.length; i &lt; il; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &amp;&amp;
            parent[peer] !== undefined) {

            present.push(peer);
        }
    }

    if (present.length === 1) {
        return null;
    }

    if (present.length === 0) {
        return Errors.create(&#039;object.missing&#039;, { peers: peers }, state, options);
    }

    return Errors.create(&#039;object.xor&#039;, { peers: peers }, state, options);
};


internals.or = function (value, peers, parent, state, options) {

    for (var i = 0, il = peers.length; i &lt; il; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &amp;&amp;
            parent[peer] !== undefined) {
            return null;
        }
    }

    return Errors.create(&#039;object.missing&#039;, { peers: peers }, state, options);
};


internals.and = function (value, peers, parent, state, options) {

    var missing = [];
    var present = [];
    var count = peers.length;
    for (var i = 0; i &lt; count; ++i) {
        var peer = peers[i];
        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||
            parent[peer] === undefined) {

            missing.push(peer);
        }
        else {
            present.push(peer);
        }
    }

    var aon = (missing.length === count || present.length === count);
    return !aon ? Errors.create(&#039;object.and&#039;, { present: present, missing: missing }, state, options) : null;
};


internals.nand = function (value, peers, parent, state, options) {

    var present = [];
    for (var i = 0, il = peers.length; i &lt; il; ++i) {
        var peer = peers[i];
        if (Object.prototype.hasOwnProperty.call(parent, peer) &amp;&amp;
            parent[peer] !== undefined) {

            present.push(peer);
        }
    }

    var values = Hoek.clone(peers);
    var main = values.splice(0, 1)[0];
    var allPresent = (present.length === peers.length);
    return allPresent ? Errors.create(&#039;object.nand&#039;, { main: main, peers: values }, state, options) : null;
};


internals.Object.prototype.describe = function (shallow) {

    var description = Any.prototype.describe.call(this);

    if (this._inner.children &amp;&amp;
        !shallow) {

        description.children = {};
        for (var i = 0, il = this._inner.children.length; i &lt; il; ++i) {
            var child = this._inner.children[i];
            description.children[child.key] = child.schema.describe();
        }
    }

    if (this._inner.dependencies.length) {
        description.dependencies = Hoek.clone(this._inner.dependencies);
    }

    if (this._inner.patterns.length) {
        description.patterns = [];

        for (var p = 0, pl = this._inner.patterns.length; p &lt; pl; ++p) {
            var pattern = this._inner.patterns[p];
            description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
        }
    }

    return description;
};


internals.Object.prototype.assert = function (ref, schema, message) {

    ref = Cast.ref(ref);
    Hoek.assert(ref.isContext || ref.depth &gt; 1, &#039;Cannot use assertions for root level references - use direct key rules instead&#039;);
    message = message || &#039;pass the assertion test&#039;;

    var cast;
    try {
        cast = Cast.schema(schema);
    }
    catch (castErr) {
        if (castErr.hasOwnProperty(&#039;path&#039;)) {
            castErr.message += &#039;(&#039; + castErr.path + &#039;)&#039;;
        }

        throw castErr;
    }

    var key = ref.path[ref.path.length - 1];
    var path = ref.path.join(&#039;.&#039;);

    return this._test(&#039;assert&#039;, { cast: cast, ref: ref }, function (value, state, options) {

        var result = cast._validate(ref(value), null, options, value);
        if (!result.errors) {
            return null;
        }

        var localState = Hoek.merge({}, state);
        localState.key = key;
        localState.path = path;
        return Errors.create(&#039;object.assert&#039;, { ref: localState.path, message: message }, localState, options);
    });
};


internals.Object.prototype.type = function (constructor, name) {

    Hoek.assert(typeof constructor === &#039;function&#039;, &#039;type must be a constructor function&#039;);
    name = name || constructor.name;

    return this._test(&#039;type&#039;, name, function (value, state, options) {

        if (value instanceof constructor) {
            return null;
        }

        return Errors.create(&#039;object.type&#039;, { type: name }, state, options);
    });
};


module.exports = new internals.Object();</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
