<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - api/node_modules/qs/test/parse.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>api/node_modules/qs/test/parse.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">478</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.17</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* eslint no-extend-native:0 */
// Load modules

var Code = require(&#039;code&#039;);
var Lab = require(&#039;lab&#039;);
var Qs = require(&#039;../&#039;);


// Declare internals

var internals = {};


// Test shortcuts

var lab = exports.lab = Lab.script();
var expect = Code.expect;
var describe = lab.experiment;
var it = lab.test;


describe(&#039;parse()&#039;, function () {

    it(&#039;parses a simple string&#039;, function (done) {

        expect(Qs.parse(&#039;0=foo&#039;)).to.deep.equal({ &#039;0&#039;: &#039;foo&#039; });
        expect(Qs.parse(&#039;foo=c++&#039;)).to.deep.equal({ foo: &#039;c  &#039; });
        expect(Qs.parse(&#039;a[&gt;=]=23&#039;)).to.deep.equal({ a: { &#039;&gt;=&#039;: &#039;23&#039; } });
        expect(Qs.parse(&#039;a[&lt;=&gt;]==23&#039;)).to.deep.equal({ a: { &#039;&lt;=&gt;&#039;: &#039;=23&#039; } });
        expect(Qs.parse(&#039;a[==]=23&#039;)).to.deep.equal({ a: { &#039;==&#039;: &#039;23&#039; } });
        expect(Qs.parse(&#039;foo&#039;, { strictNullHandling: true })).to.deep.equal({ foo: null });
        expect(Qs.parse(&#039;foo&#039; )).to.deep.equal({ foo: &#039;&#039; });
        expect(Qs.parse(&#039;foo=&#039;)).to.deep.equal({ foo: &#039;&#039; });
        expect(Qs.parse(&#039;foo=bar&#039;)).to.deep.equal({ foo: &#039;bar&#039; });
        expect(Qs.parse(&#039; foo = bar = baz &#039;)).to.deep.equal({ &#039; foo &#039;: &#039; bar = baz &#039; });
        expect(Qs.parse(&#039;foo=bar=baz&#039;)).to.deep.equal({ foo: &#039;bar=baz&#039; });
        expect(Qs.parse(&#039;foo=bar&amp;bar=baz&#039;)).to.deep.equal({ foo: &#039;bar&#039;, bar: &#039;baz&#039; });
        expect(Qs.parse(&#039;foo2=bar2&amp;baz2=&#039;)).to.deep.equal({ foo2: &#039;bar2&#039;, baz2: &#039;&#039; });
        expect(Qs.parse(&#039;foo=bar&amp;baz&#039;, { strictNullHandling: true })).to.deep.equal({ foo: &#039;bar&#039;, baz: null });
        expect(Qs.parse(&#039;foo=bar&amp;baz&#039;)).to.deep.equal({ foo: &#039;bar&#039;, baz: &#039;&#039; });
        expect(Qs.parse(&#039;cht=p3&amp;chd=t:60,40&amp;chs=250x100&amp;chl=Hello|World&#039;)).to.deep.equal({
            cht: &#039;p3&#039;,
            chd: &#039;t:60,40&#039;,
            chs: &#039;250x100&#039;,
            chl: &#039;Hello|World&#039;
        });
        done();
    });

    it(&#039;allows disabling dot notation&#039;, function (done) {

        expect(Qs.parse(&#039;a.b=c&#039;)).to.deep.equal({ a: { b: &#039;c&#039; } });
        expect(Qs.parse(&#039;a.b=c&#039;, { allowDots: false })).to.deep.equal({ &#039;a.b&#039;: &#039;c&#039; });
        done();
    });

    it(&#039;parses a single nested string&#039;, function (done) {

        expect(Qs.parse(&#039;a[b]=c&#039;)).to.deep.equal({ a: { b: &#039;c&#039; } });
        done();
    });

    it(&#039;parses a double nested string&#039;, function (done) {

        expect(Qs.parse(&#039;a[b][c]=d&#039;)).to.deep.equal({ a: { b: { c: &#039;d&#039; } } });
        done();
    });

    it(&#039;defaults to a depth of 5&#039;, function (done) {

        expect(Qs.parse(&#039;a[b][c][d][e][f][g][h]=i&#039;)).to.deep.equal({ a: { b: { c: { d: { e: { f: { &#039;[g][h]&#039;: &#039;i&#039; } } } } } } });
        done();
    });

    it(&#039;only parses one level when depth = 1&#039;, function (done) {

        expect(Qs.parse(&#039;a[b][c]=d&#039;, { depth: 1 })).to.deep.equal({ a: { b: { &#039;[c]&#039;: &#039;d&#039; } } });
        expect(Qs.parse(&#039;a[b][c][d]=e&#039;, { depth: 1 })).to.deep.equal({ a: { b: { &#039;[c][d]&#039;: &#039;e&#039; } } });
        done();
    });

    it(&#039;parses a simple array&#039;, function (done) {

        expect(Qs.parse(&#039;a=b&amp;a=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        done();
    });

    it(&#039;parses an explicit array&#039;, function (done) {

        expect(Qs.parse(&#039;a[]=b&#039;)).to.deep.equal({ a: [&#039;b&#039;] });
        expect(Qs.parse(&#039;a[]=b&amp;a[]=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a[]=b&amp;a[]=c&amp;a[]=d&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] });
        done();
    });

    it(&#039;parses a mix of simple and explicit arrays&#039;, function (done) {

        expect(Qs.parse(&#039;a=b&amp;a[]=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a[]=b&amp;a=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a[0]=b&amp;a=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a=b&amp;a[0]=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a[1]=b&amp;a=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a=b&amp;a[1]=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        done();
    });

    it(&#039;parses a nested array&#039;, function (done) {

        expect(Qs.parse(&#039;a[b][]=c&amp;a[b][]=d&#039;)).to.deep.equal({ a: { b: [&#039;c&#039;, &#039;d&#039;] } });
        expect(Qs.parse(&#039;a[&gt;=]=25&#039;)).to.deep.equal({ a: { &#039;&gt;=&#039;: &#039;25&#039; } });
        done();
    });

    it(&#039;allows to specify array indices&#039;, function (done) {

        expect(Qs.parse(&#039;a[1]=c&amp;a[0]=b&amp;a[2]=d&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;, &#039;d&#039;] });
        expect(Qs.parse(&#039;a[1]=c&amp;a[0]=b&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a[1]=c&#039;)).to.deep.equal({ a: [&#039;c&#039;] });
        done();
    });

    it(&#039;limits specific array indices to 20&#039;, function (done) {

        expect(Qs.parse(&#039;a[20]=a&#039;)).to.deep.equal({ a: [&#039;a&#039;] });
        expect(Qs.parse(&#039;a[21]=a&#039;)).to.deep.equal({ a: { &#039;21&#039;: &#039;a&#039; } });
        done();
    });

    it(&#039;supports keys that begin with a number&#039;, function (done) {

        expect(Qs.parse(&#039;a[12b]=c&#039;)).to.deep.equal({ a: { &#039;12b&#039;: &#039;c&#039; } });
        done();
    });

    it(&#039;supports encoded = signs&#039;, function (done) {

        expect(Qs.parse(&#039;he%3Dllo=th%3Dere&#039;)).to.deep.equal({ &#039;he=llo&#039;: &#039;th=ere&#039; });
        done();
    });

    it(&#039;is ok with url encoded strings&#039;, function (done) {

        expect(Qs.parse(&#039;a[b%20c]=d&#039;)).to.deep.equal({ a: { &#039;b c&#039;: &#039;d&#039; } });
        expect(Qs.parse(&#039;a[b]=c%20d&#039;)).to.deep.equal({ a: { b: &#039;c d&#039; } });
        done();
    });

    it(&#039;allows brackets in the value&#039;, function (done) {

        expect(Qs.parse(&#039;pets=[&quot;tobi&quot;]&#039;)).to.deep.equal({ pets: &#039;[&quot;tobi&quot;]&#039; });
        expect(Qs.parse(&#039;operators=[&quot;&gt;=&quot;, &quot;&lt;=&quot;]&#039;)).to.deep.equal({ operators: &#039;[&quot;&gt;=&quot;, &quot;&lt;=&quot;]&#039; });
        done();
    });

    it(&#039;allows empty values&#039;, function (done) {

        expect(Qs.parse(&#039;&#039;)).to.deep.equal({});
        expect(Qs.parse(null)).to.deep.equal({});
        expect(Qs.parse(undefined)).to.deep.equal({});
        done();
    });

    it(&#039;transforms arrays to objects&#039;, function (done) {

        expect(Qs.parse(&#039;foo[0]=bar&amp;foo[bad]=baz&#039;)).to.deep.equal({ foo: { &#039;0&#039;: &#039;bar&#039;, bad: &#039;baz&#039; } });
        expect(Qs.parse(&#039;foo[bad]=baz&amp;foo[0]=bar&#039;)).to.deep.equal({ foo: { bad: &#039;baz&#039;, &#039;0&#039;: &#039;bar&#039; } });
        expect(Qs.parse(&#039;foo[bad]=baz&amp;foo[]=bar&#039;)).to.deep.equal({ foo: { bad: &#039;baz&#039;, &#039;0&#039;: &#039;bar&#039; } });
        expect(Qs.parse(&#039;foo[]=bar&amp;foo[bad]=baz&#039;)).to.deep.equal({ foo: { &#039;0&#039;: &#039;bar&#039;, bad: &#039;baz&#039; } });
        expect(Qs.parse(&#039;foo[bad]=baz&amp;foo[]=bar&amp;foo[]=foo&#039;)).to.deep.equal({ foo: { bad: &#039;baz&#039;, &#039;0&#039;: &#039;bar&#039;, &#039;1&#039;: &#039;foo&#039; } });
        expect(Qs.parse(&#039;foo[0][a]=a&amp;foo[0][b]=b&amp;foo[1][a]=aa&amp;foo[1][b]=bb&#039;)).to.deep.equal({ foo: [{ a: &#039;a&#039;, b: &#039;b&#039; }, { a: &#039;aa&#039;, b: &#039;bb&#039; }] });
        expect(Qs.parse(&#039;a[]=b&amp;a[t]=u&amp;a[hasOwnProperty]=c&#039;)).to.deep.equal({ a: { &#039;0&#039;: &#039;b&#039;, t: &#039;u&#039;, c: true } });
        expect(Qs.parse(&#039;a[]=b&amp;a[hasOwnProperty]=c&amp;a[x]=y&#039;)).to.deep.equal({ a: { &#039;0&#039;: &#039;b&#039;, &#039;1&#039;: &#039;c&#039;, x: &#039;y&#039; } });
        done();
    });

    it(&#039;transforms arrays to objects (dot notation)&#039;, function (done) {

        expect(Qs.parse(&#039;foo[0].baz=bar&amp;fool.bad=baz&#039;)).to.deep.equal({ foo: [{ baz: &#039;bar&#039; }], fool: { bad: &#039;baz&#039; } });
        expect(Qs.parse(&#039;foo[0].baz=bar&amp;fool.bad.boo=baz&#039;)).to.deep.equal({ foo: [{ baz: &#039;bar&#039; }], fool: { bad: { boo: &#039;baz&#039; } } });
        expect(Qs.parse(&#039;foo[0][0].baz=bar&amp;fool.bad=baz&#039;)).to.deep.equal({ foo: [[{ baz: &#039;bar&#039; }]], fool: { bad: &#039;baz&#039; } });
        expect(Qs.parse(&#039;foo[0].baz[0]=15&amp;foo[0].bar=2&#039;)).to.deep.equal({ foo: [{ baz: [&#039;15&#039;], bar: &#039;2&#039; }] });
        expect(Qs.parse(&#039;foo[0].baz[0]=15&amp;foo[0].baz[1]=16&amp;foo[0].bar=2&#039;)).to.deep.equal({ foo: [{ baz: [&#039;15&#039;, &#039;16&#039;], bar: &#039;2&#039; }] });
        expect(Qs.parse(&#039;foo.bad=baz&amp;foo[0]=bar&#039;)).to.deep.equal({ foo: { bad: &#039;baz&#039;, &#039;0&#039;: &#039;bar&#039; } });
        expect(Qs.parse(&#039;foo.bad=baz&amp;foo[]=bar&#039;)).to.deep.equal({ foo: { bad: &#039;baz&#039;, &#039;0&#039;: &#039;bar&#039; } });
        expect(Qs.parse(&#039;foo[]=bar&amp;foo.bad=baz&#039;)).to.deep.equal({ foo: { &#039;0&#039;: &#039;bar&#039;, bad: &#039;baz&#039; } });
        expect(Qs.parse(&#039;foo.bad=baz&amp;foo[]=bar&amp;foo[]=foo&#039;)).to.deep.equal({ foo: { bad: &#039;baz&#039;, &#039;0&#039;: &#039;bar&#039;, &#039;1&#039;: &#039;foo&#039; } });
        expect(Qs.parse(&#039;foo[0].a=a&amp;foo[0].b=b&amp;foo[1].a=aa&amp;foo[1].b=bb&#039;)).to.deep.equal({ foo: [{ a: &#039;a&#039;, b: &#039;b&#039; }, { a: &#039;aa&#039;, b: &#039;bb&#039; }] });
        done();
    });

    it(&#039;can add keys to objects&#039;, function (done) {

        expect(Qs.parse(&#039;a[b]=c&amp;a=d&#039;)).to.deep.equal({ a: { b: &#039;c&#039;, d: true } });
        done();
    });

    it(&#039;correctly prunes undefined values when converting an array to an object&#039;, function (done) {

        expect(Qs.parse(&#039;a[2]=b&amp;a[99999999]=c&#039;)).to.deep.equal({ a: { &#039;2&#039;: &#039;b&#039;, &#039;99999999&#039;: &#039;c&#039; } });
        done();
    });

    it(&#039;supports malformed uri characters&#039;, function (done) {

        expect(Qs.parse(&#039;{%:%}&#039;, { strictNullHandling: true })).to.deep.equal({ &#039;{%:%}&#039;: null });
        expect(Qs.parse(&#039;{%:%}=&#039;)).to.deep.equal({ &#039;{%:%}&#039;: &#039;&#039; });
        expect(Qs.parse(&#039;foo=%:%}&#039;)).to.deep.equal({ foo: &#039;%:%}&#039; });
        done();
    });

    it(&#039;doesn\&#039;t produce empty keys&#039;, function (done) {

        expect(Qs.parse(&#039;_r=1&amp;&#039;)).to.deep.equal({ &#039;_r&#039;: &#039;1&#039; });
        done();
    });

    it(&#039;cannot access Object prototype&#039;, function (done) {

        Qs.parse(&#039;constructor[prototype][bad]=bad&#039;);
        Qs.parse(&#039;bad[constructor][prototype][bad]=bad&#039;);
        expect(typeof Object.prototype.bad).to.equal(&#039;undefined&#039;);
        done();
    });

    it(&#039;parses arrays of objects&#039;, function (done) {

        expect(Qs.parse(&#039;a[][b]=c&#039;)).to.deep.equal({ a: [{ b: &#039;c&#039; }] });
        expect(Qs.parse(&#039;a[0][b]=c&#039;)).to.deep.equal({ a: [{ b: &#039;c&#039; }] });
        done();
    });

    it(&#039;allows for empty strings in arrays&#039;, function (done) {

        expect(Qs.parse(&#039;a[]=b&amp;a[]=&amp;a[]=c&#039;)).to.deep.equal({ a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;] });
        expect(Qs.parse(&#039;a[0]=b&amp;a[1]&amp;a[2]=c&amp;a[19]=&#039;, { strictNullHandling: true })).to.deep.equal({ a: [&#039;b&#039;, null, &#039;c&#039;, &#039;&#039;] });
        expect(Qs.parse(&#039;a[0]=b&amp;a[1]=&amp;a[2]=c&amp;a[19]&#039;, { strictNullHandling: true })).to.deep.equal({ a: [&#039;b&#039;, &#039;&#039;, &#039;c&#039;, null] });
        expect(Qs.parse(&#039;a[]=&amp;a[]=b&amp;a[]=c&#039;)).to.deep.equal({ a: [&#039;&#039;, &#039;b&#039;, &#039;c&#039;] });
        done();
    });

    it(&#039;compacts sparse arrays&#039;, function (done) {

        expect(Qs.parse(&#039;a[10]=1&amp;a[2]=2&#039;)).to.deep.equal({ a: [&#039;2&#039;, &#039;1&#039;] });
        done();
    });

    it(&#039;parses semi-parsed strings&#039;, function (done) {

        expect(Qs.parse({ &#039;a[b]&#039;: &#039;c&#039; })).to.deep.equal({ a: { b: &#039;c&#039; } });
        expect(Qs.parse({ &#039;a[b]&#039;: &#039;c&#039;, &#039;a[d]&#039;: &#039;e&#039; })).to.deep.equal({ a: { b: &#039;c&#039;, d: &#039;e&#039; } });
        done();
    });

    it(&#039;parses buffers correctly&#039;, function (done) {

        var b = new Buffer(&#039;test&#039;);
        expect(Qs.parse({ a: b })).to.deep.equal({ a: b });
        done();
    });

    it(&#039;continues parsing when no parent is found&#039;, function (done) {

        expect(Qs.parse(&#039;[]=&amp;a=b&#039;)).to.deep.equal({ &#039;0&#039;: &#039;&#039;, a: &#039;b&#039; });
        expect(Qs.parse(&#039;[]&amp;a=b&#039;, { strictNullHandling: true })).to.deep.equal({ &#039;0&#039;: null, a: &#039;b&#039; });
        expect(Qs.parse(&#039;[foo]=bar&#039;)).to.deep.equal({ foo: &#039;bar&#039; });
        done();
    });

    it(&#039;does not error when parsing a very long array&#039;, function (done) {

        var str = &#039;a[]=a&#039;;
        while (Buffer.byteLength(str) &lt; 128 * 1024) {
            str += &#039;&amp;&#039; + str;
        }

        expect(function () {

            Qs.parse(str);
        }).to.not.throw();

        done();
    });

    it(&#039;should not throw when a native prototype has an enumerable property&#039;, { parallel: false }, function (done) {

        Object.prototype.crash = &#039;&#039;;
        Array.prototype.crash = &#039;&#039;;
        expect(Qs.parse.bind(null, &#039;a=b&#039;)).to.not.throw();
        expect(Qs.parse(&#039;a=b&#039;)).to.deep.equal({ a: &#039;b&#039; });
        expect(Qs.parse.bind(null, &#039;a[][b]=c&#039;)).to.not.throw();
        expect(Qs.parse(&#039;a[][b]=c&#039;)).to.deep.equal({ a: [{ b: &#039;c&#039; }] });
        delete Object.prototype.crash;
        delete Array.prototype.crash;
        done();
    });

    it(&#039;parses a string with an alternative string delimiter&#039;, function (done) {

        expect(Qs.parse(&#039;a=b;c=d&#039;, { delimiter: &#039;;&#039; })).to.deep.equal({ a: &#039;b&#039;, c: &#039;d&#039; });
        done();
    });

    it(&#039;parses a string with an alternative RegExp delimiter&#039;, function (done) {

        expect(Qs.parse(&#039;a=b; c=d&#039;, { delimiter: /[;,] */ })).to.deep.equal({ a: &#039;b&#039;, c: &#039;d&#039; });
        done();
    });

    it(&#039;does not use non-splittable objects as delimiters&#039;, function (done) {

        expect(Qs.parse(&#039;a=b&amp;c=d&#039;, { delimiter: true })).to.deep.equal({ a: &#039;b&#039;, c: &#039;d&#039; });
        done();
    });

    it(&#039;allows overriding parameter limit&#039;, function (done) {

        expect(Qs.parse(&#039;a=b&amp;c=d&#039;, { parameterLimit: 1 })).to.deep.equal({ a: &#039;b&#039; });
        done();
    });

    it(&#039;allows setting the parameter limit to Infinity&#039;, function (done) {

        expect(Qs.parse(&#039;a=b&amp;c=d&#039;, { parameterLimit: Infinity })).to.deep.equal({ a: &#039;b&#039;, c: &#039;d&#039; });
        done();
    });

    it(&#039;allows overriding array limit&#039;, function (done) {

        expect(Qs.parse(&#039;a[0]=b&#039;, { arrayLimit: -1 })).to.deep.equal({ a: { &#039;0&#039;: &#039;b&#039; } });
        expect(Qs.parse(&#039;a[-1]=b&#039;, { arrayLimit: -1 })).to.deep.equal({ a: { &#039;-1&#039;: &#039;b&#039; } });
        expect(Qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { arrayLimit: 0 })).to.deep.equal({ a: { &#039;0&#039;: &#039;b&#039;, &#039;1&#039;: &#039;c&#039; } });
        done();
    });

    it(&#039;allows disabling array parsing&#039;, function (done) {

        expect(Qs.parse(&#039;a[0]=b&amp;a[1]=c&#039;, { parseArrays: false })).to.deep.equal({ a: { &#039;0&#039;: &#039;b&#039;, &#039;1&#039;: &#039;c&#039; } });
        done();
    });

    it(&#039;parses an object&#039;, function (done) {

        var input = {
            &#039;user[name]&#039;: { &#039;pop[bob]&#039;: 3 },
            &#039;user[email]&#039;: null
        };

        var expected = {
            &#039;user&#039;: {
                &#039;name&#039;: { &#039;pop[bob]&#039;: 3 },
                &#039;email&#039;: null
            }
        };

        var result = Qs.parse(input);

        expect(result).to.deep.equal(expected);
        done();
    });

    it(&#039;parses an object in dot notation&#039;, function (done) {

        var input = {
            &#039;user.name&#039;: { &#039;pop[bob]&#039;: 3 },
            &#039;user.email.&#039;: null
        };

        var expected = {
            &#039;user&#039;: {
                &#039;name&#039;: { &#039;pop[bob]&#039;: 3 },
                &#039;email&#039;: null
            }
        };

        var result = Qs.parse(input);

        expect(result).to.deep.equal(expected);
        done();
    });

    it(&#039;parses an object and not child values&#039;, function (done) {

        var input = {
            &#039;user[name]&#039;: { &#039;pop[bob]&#039;: { &#039;test&#039;: 3 } },
            &#039;user[email]&#039;: null
        };

        var expected = {
            &#039;user&#039;: {
                &#039;name&#039;: { &#039;pop[bob]&#039;: { &#039;test&#039;: 3 } },
                &#039;email&#039;: null
            }
        };

        var result = Qs.parse(input);

        expect(result).to.deep.equal(expected);
        done();
    });

    it(&#039;does not blow up when Buffer global is missing&#039;, function (done) {

        var tempBuffer = global.Buffer;
        delete global.Buffer;
        var result = Qs.parse(&#039;a=b&amp;c=d&#039;);
        global.Buffer = tempBuffer;
        expect(result).to.deep.equal({ a: &#039;b&#039;, c: &#039;d&#039; });
        done();
    });

    it(&#039;does not crash when parsing circular references&#039;, function (done) {

        var a = {};
        a.b = a;

        var parsed;

        expect(function () {

            parsed = Qs.parse({ &#039;foo[bar]&#039;: &#039;baz&#039;, &#039;foo[baz]&#039;: a });
        }).to.not.throw();

        expect(parsed).to.contain(&#039;foo&#039;);
        expect(parsed.foo).to.contain(&#039;bar&#039;, &#039;baz&#039;);
        expect(parsed.foo.bar).to.equal(&#039;baz&#039;);
        expect(parsed.foo.baz).to.deep.equal(a);
        done();
    });

    it(&#039;parses plain objects correctly&#039;, function (done) {

        var a = Object.create(null);
        a.b = &#039;c&#039;;

        expect(Qs.parse(a)).to.deep.equal({ b: &#039;c&#039; });
        var result = Qs.parse({ a: a });
        expect(result).to.contain(&#039;a&#039;);
        expect(result.a).to.deep.equal(a);
        done();
    });

    it(&#039;parses dates correctly&#039;, function (done) {

        var now = new Date();
        expect(Qs.parse({ a: now })).to.deep.equal({ a: now });
        done();
    });

    it(&#039;parses regular expressions correctly&#039;, function (done) {

        var re = /^test$/;
        expect(Qs.parse({ a: re })).to.deep.equal({ a: re });
        done();
    });

    it(&#039;can allow overwriting prototype properties&#039;, function (done) {

        expect(Qs.parse(&#039;a[hasOwnProperty]=b&#039;, { allowPrototypes: true })).to.deep.equal({ a: { hasOwnProperty: &#039;b&#039; } }, { prototype: false });
        expect(Qs.parse(&#039;hasOwnProperty=b&#039;, { allowPrototypes: true })).to.deep.equal({ hasOwnProperty: &#039;b&#039; }, { prototype: false });
        done();
    });

    it(&#039;can return plain objects&#039;, function (done) {

        var expected = Object.create(null);
        expected.a = Object.create(null);
        expected.a.b = &#039;c&#039;;
        expected.a.hasOwnProperty = &#039;d&#039;;
        expect(Qs.parse(&#039;a[b]=c&amp;a[hasOwnProperty]=d&#039;, { plainObjects: true })).to.deep.equal(expected);
        expect(Qs.parse(null, { plainObjects: true })).to.deep.equal(Object.create(null));
        var expectedArray = Object.create(null);
        expectedArray.a = Object.create(null);
        expectedArray.a[&#039;0&#039;] = &#039;b&#039;;
        expectedArray.a.c = &#039;d&#039;;
        expect(Qs.parse(&#039;a[]=b&amp;a[c]=d&#039;, { plainObjects: true })).to.deep.equal(expectedArray);
        done();
    });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
